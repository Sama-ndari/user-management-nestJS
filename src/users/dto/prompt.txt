my CreateUserDto

import { IsString, IsEmail, IsNotEmpty, IsEnum, IsOptional, MinLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateUserDto {
  @IsString()
  @IsNotEmpty()
  @ApiProperty({ description: 'The username of the user', example: 'johndoe' })
  username: string;

  @IsEmail()
  @IsNotEmpty()
  @ApiProperty({ description: 'The email address of the user', example: 'johndoe@example.com' })
  email: string;

  @IsString()
  @IsNotEmpty()
  @MinLength(5)
  @ApiProperty({ description: 'The password of the user', example: 'P@ssw0rd' })
  password: string;

  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The first name of the user', example: 'Optional' })
  firstName?: string;

  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The last name of the user', example: 'Optional' })
  lastName?: string;

  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The phone number of the user', example: 'Optional', required: false })
  phone?: string;

  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The address of the user', example: 'Optional', required: false })
  address?: string;

  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The card number associated with the user', example: 'Optional', required: false })
  cardNumber?: string;

  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The logo or avatar of the user', example: 'Optional', required: false })
  logo?: string;

  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The status of the user', example: 'Optional', default: 'active', required: false })
  status?: 'active' | 'inactive' | 'pending';

  @IsString()
  @IsNotEmpty()
  @ApiProperty({ description: 'The role of the user', example: 'Admin' })
  role: 'Admin' | 'Customer' | 'Merchant' | 'Commissionaire';
}

export class UserRepresentation {
  username: string;
  email: string;
  firstName?: string;
  lastName?: string;
  credentials: Credential[];
  enabled: boolean;
  emailVerified: boolean;
  attributes?: {
    phone?: string;
    address?: string;
    cardNumber?: string;
    logo?: string;
    status?: 'active' | 'inactive' | 'pending';
    role: 'Admin' | 'Customer' | 'Merchant' | 'Commissionaire';
  };
}
export class Credential {
  type: string;
  value: string;
  temporary: boolean;
}

export class RoleRepresentation{
  id:string;
  name:string;
  description:string;
  composite:string;
  clientRole:string;
  containerId:string
}

export class CreateUserDatabaseDto {
  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The unique identifier for the user in Keycloak', example: '123e4567-e89b-12d3-a456-426614174000' })
  keycloakId: string;

  @IsString()
  @IsNotEmpty()
  @ApiProperty({ description: 'The username of the user', example: 'johndoe' })
  username: string;

  @IsString()
  @IsNotEmpty()
  @ApiProperty({ description: 'The email address of the user', example: 'johndoe@example.com' })
  email: string;

  @IsString()
  @IsNotEmpty()
  @ApiProperty({ description: 'The password of the user', example: 'P@ssw0rd' })
  password: string;

  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The first name of the user', example: 'John' })
  firstName?: string;

  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The last name of the user', example: 'Doe' })
  lastName?: string;

  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The phone number of the user', example: '+1234567890', required: false })
  phone?: string;

  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The address of the user', example: '123 Main St, Springfield', required: false })
  address?: string;

  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The card number associated with the user', example: '4111111111111111', required: false })
  cardNumber?: string;

  @IsString()
  @IsOptional()
  @ApiProperty({ description: 'The logo or avatar of the user', example: 'https://example.com/logo.png', required: false })
  logo?: string;

  @ApiProperty({ description: 'The status of the user', example: 'active', default: 'active', required: false })
  status?: 'active' | 'inactive' | 'pending';

  @IsString()
  @IsNotEmpty()
  @ApiProperty({ description: 'The role of the user', example: 'admin' })
  role: string;
}

export class ResetPasswordDto {
  @IsString()
  @IsNotEmpty()
  @ApiProperty({ description: 'The password of the user', example: 'Password123$' })
  newPassword: string;
}


my loginDTO:

import { IsString, IsNotEmpty } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class LoginDto {
  @ApiProperty({ example: 'john_doe' })
  @IsString()
  @IsNotEmpty()
  username: string;

  @ApiProperty({ example: 'securePassword123' })
  @IsString()
  @IsNotEmpty()
  password: string;
}

my conroller:

import { Controller, Post, Body, Get, Request, Patch, Delete, Param, Put, HttpCode, HttpStatus } from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto, ResetPasswordDto } from './dto/create-user.dto';
import { Roles } from 'nest-keycloak-connect';
import { ApiBody, ApiOperation, ApiParam, ApiTags } from '@nestjs/swagger';
import { UpdateUserDto } from './dto/update-user.dto';
import { KeycloakService } from 'src/keycloak/keycloak.service';
import { LoginDto } from './dto/login.dto';
import { LogoutDto } from './dto/logout.dto';

@ApiTags('user')
@Controller('users')
export class UsersController {
  constructor(
    private readonly usersService: UsersService,
  ) { }

  @Post('login')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'Login a user' })
  @ApiBody({ type: LoginDto })
  async login(@Body() body: { username: string; password: string }): Promise<any> {
    const tokenData = await this.usersService.login(body);
    return { message: 'Login successful', tokenData };
  }

  @Post('logout')
  @ApiOperation({ summary: 'Logout a user' })
  @ApiBody({ type: LogoutDto })
  async logout(@Body() body: { refreshToken: string }): Promise<any> {
    await this.usersService.logout(body.refreshToken);
    return { message: 'Logout successful' };
  }

  @Post()
  @ApiOperation({ summary: 'Create a new user' })
  @ApiBody({ type: CreateUserDto })
  @Roles({ roles: ['Admin'] }) // Only Admins can create users
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.createUser(createUserDto);
  }

  @Put('/:id')
  @ApiParam({ name: 'id', description: 'User ID' })
  @ApiBody({ type: UpdateUserDto })
  @ApiOperation({ summary: 'update a user' })
  @Roles({ roles: ['Admin'] }) // Only Admins can update users
  update(@Param('id') id: string, @Body() updateData: UpdateUserDto) {
    return this.usersService.updateUser(id, updateData);
  }

  @Post('reset-password/:id')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'reset a user password' })
  @ApiBody({ type: ResetPasswordDto})
  async resetPassword(
    @Param('id') id: string,
    @Body() body: ResetPasswordDto,
  ): Promise<any> {
    const updatedUser = await this.usersService.resetPassword(id, body.newPassword);
    return { message: 'Password reset successfully', user: updatedUser };
  }

  @Put('/:id/assign-role/:role')
  @ApiParam({ name: 'id', description: 'User ID' })
  @ApiParam({ name: 'role', description: 'Role name' })
  @ApiOperation({ summary: 'assign a role' })
  @Roles({ roles: ['Admin'] }) // Only Admins can assign roles
  async assignRole(@Param('id') userId: string, @Param('role') role: string) {
    await this.usersService.assignRole(userId, role);
  }

  @Put('/:id/deassign-role/:role')
  @ApiParam({ name: 'id', description: 'User ID' })
  @ApiParam({ name: 'role', description: 'Role name' })
  @ApiOperation({ summary: 'deAssignRole a role' })
  @Roles({ roles: ['Admin'] }) // Only Admins can assign roles
  async deAssignRole(@Param('id') userId: string, @Param('role') role: string) {
    await this.usersService.deAssignRole(userId, role);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete a new user' })
  @Roles({ roles: ['Admin'] }) // Only Admins can delete users
  async delete(@Param('id') id: string) {
    return this.usersService.deleteUser(id);
  }

  // @Get('profile')
  // @Roles({ roles: ['Customer', 'Merchant', 'Commissionaire'] }) // Accessible to non-Admin roles
  // getProfile(@Request() req) {
  //   return req.user; // Returns user info from the JWT token
  // }

  @Get('users-by-role/:role')
  @ApiOperation({ summary: 'Find all users by role name' })
  @Roles({ roles: ['Admin'] })  // Only accessible by users with the admin role.
  findByRole(@Param('role') role: string) {
    return this.usersService.findAllUsersByRole(role);
  }

  @Get()
  @ApiOperation({ summary: 'Find all users' })
  @Roles({ roles: ['Admin'] })  // Only accessible by users with the admin role.
  findAll() {
    return this.usersService.findAllUsers();
  }

  @Get('by-id/:id')
  @ApiOperation({ summary: 'Find a user by ID' })
  @Roles({ roles: ['Admin'] })  // Only accessible by users with the admin role.
  findById(@Param('id') id: string) {
    return this.usersService.findUserById(id);
  }

  @Get('by-username/:username')
  @ApiOperation({ summary: 'Find a user by username' })
  @Roles({ roles: ['Admin'] })  // Only accessible by users with the admin role.
  findByName(@Param('username') username: string) {
    return this.usersService.findUserByUsername(username);
  }

  @Get('by-email/:email')
  @ApiOperation({ summary: 'Find a user by email' })
  @Roles({ roles: ['Admin'] })  // Only accessible by users with the admin role.
  findByEmail(@Param('email') email: string) {
    return this.usersService.findUserByEmail(email);
  }
}

userService:

import { Delete, HttpException, HttpStatus, Injectable, NotFoundException } from '@nestjs/common';
import { KeycloakService } from '../keycloak/keycloak.service';
import { CreateUserDto, UserRepresentation } from './dto/create-user.dto';
import { DatabaseService } from 'src/database/database.service';
import { TransactionsService } from 'src/transactions/transactions.service';
import axios from 'axios';
import * as dotenv from 'dotenv';
import { LoginDto } from './dto/login.dto';
dotenv.config();

@Injectable()
export class UsersService {
  constructor(
    private keycloakService: KeycloakService,
    private databaseService: DatabaseService,
    private transactionsService: TransactionsService,
  ) { }

  async login(userdto : LoginDto): Promise<any> {
    return this.transactionsService.login(userdto);
  }

  async logout(refreshToken: string): Promise<any> {
    return this.transactionsService.logout(refreshToken);
  }


  async createUser(userDto: any): Promise<any> {
    const createdUser = await this.transactionsService.createUser(userDto);
    return createdUser;
  }

  async updateUser(id: string, userDto: any) {
    const updatedUser = await this.transactionsService.updateUser(id, userDto);
    return updatedUser;
  }

  async resetPassword(id: string, newPassword: string): Promise<any> {
    return this.transactionsService.resetPassword(id, newPassword);
  }
  
  async findUserById(id: string): Promise<UserRepresentation> {
    return this.transactionsService.findUserById(id);
  }

  async findUserByUsername(username: string): Promise<UserRepresentation> {
    return this.transactionsService.findUserByUsername(username);
  }

  async findAllUsersByRole(roleName: string): Promise<UserRepresentation[]> {
    return this.transactionsService.findAllUsersByRole(roleName);
  }

  async findAllUsers(): Promise<UserRepresentation[]> {
    return this.transactionsService.findAllUsers();
  }

  async findUserByEmail(email: string): Promise<UserRepresentation> {
    return this.transactionsService.findUserByEmail(email);
  }

  async deleteUser(id: string) {
    const deletedUser = await this.transactionsService.deleteUser(id);
    return await { message: 'User deleted successfully', DeletedUser: deletedUser };
  }

  async assignRole(userId: string, roleName: string) {
    await this.transactionsService.assignRole(userId, roleName);
    return { message: 'Role assigned successfully' };
  }

  async deAssignRole(userId: string, roleName: string) {
    await this.transactionsService.deAssignRole(userId, roleName);
    return { message: 'Role deAssigned successfully' };
  }
}

transactionsService:

import { HttpException, HttpStatus, Injectable, NotFoundException } from '@nestjs/common';
import { KeycloakService } from '../keycloak/keycloak.service';
import { CreateUserDatabaseDto, CreateUserDto, UserRepresentation } from '../users/dto/create-user.dto';
import { DatabaseService } from 'src/database/database.service';
import { Connection } from 'mongoose';
import { InjectConnection } from '@nestjs/mongoose';
import { LoginDto } from 'src/users/dto/login.dto';
import { LogoutDto } from 'src/users/dto/logout.dto';

@Injectable()
export class TransactionsService {
    constructor(
        private keycloakService: KeycloakService,
        private databaseService: DatabaseService,
        @InjectConnection() private readonly connection: Connection,
    ) { }

    async login(userDto: LoginDto): Promise<any> {
        try {
            const keycloakResponse = await this.keycloakService.login(userDto);
            if (!keycloakResponse || !keycloakResponse.access_token) {
                throw new HttpException('Invalid credentials', HttpStatus.UNAUTHORIZED);
            }

            const dbUser = await this.databaseService.findUserByUsername(userDto.username);
            if (!dbUser) {
                // If the user doesn't exist in your DB, you might choose to create a new entry or throw an error.
                throw new NotFoundException('User not found in database');
            }

            const mergedUser = {
                ...dbUser,
                // username: keycloakUser.username,
                // email: keycloakUser.email,
                // firstName: keycloakUser.firstName,
                // lastName: keycloakUser.lastName,
                // roles: keycloakUser.attributes?.role || [],
                // add additional fields from dbUser as needed
            };

            // 4. Return a payload that includes the authentication tokens and merged user profile.
            return {
                accessToken: keycloakResponse.access_token,
                refreshToken: keycloakResponse.refresh_token,
                user: mergedUser,
            };
        } catch (error) {
            throw new HttpException(error.message || 'Login failed', HttpStatus.UNAUTHORIZED);
        }
    }

    async logout(token: string): Promise<any> {
        return this.keycloakService.logout(token);
    }

    async createUser(userDto: any): Promise<any> {
        let keycloakId;
        // Start a Mongoose session
        const session = await this.connection.startSession();
        session.startTransaction();

        try {
            // ---------------------- STEP 1: Keycloak Operation ----------------------
            // Build the payload for Keycloak. Adjust the payload as required by your Keycloak API.
            const keycloakUserPayload = Object.fromEntries(
                Object.entries({
                    username: userDto.username,
                    email: userDto.email,
                    firstName: userDto.firstName,
                    lastName: userDto.lastName,
                    credentials: userDto.password
                        ? [{ type: 'password', value: userDto.password, temporary: false }]
                        : undefined,
                    enabled: true,
                    emailVerified: false,
                    attributes: {
                        phone: userDto.phone,
                        address: userDto.address,
                        cardNumber: userDto.cardNumber,
                        logo: userDto.logo,
                        status: userDto.status || 'pending',
                        role: userDto.role,
                    },
                }).filter(([_, value]) => value !== undefined && value !== null)
            );

            // Create the user in Keycloak.
            const createdKeycloakUser = await this.keycloakService.createUser(keycloakUserPayload);
            // If the Keycloak call fails, it should throw and the following lines won't execute.
            console.log('Keycloak user created:', createdKeycloakUser);

            keycloakId = createdKeycloakUser.id;

            const userForDB = { ...userDto, keycloakId: createdKeycloakUser.id };

            // Pass the Mongoose session into the database service to ensure transactionality.
            const createdUser = await this.databaseService.createUser(userForDB, session);
            console.log('Database user created:', createdUser);

            // Commit the transaction if both operations succeed.
            await session.commitTransaction();
            session.endSession();

            return { message: 'User Created successful! Please check your email to verify your account.', user: createdUser };
            // return createdUser;
        } catch (error) {
            // Roll back the database changes
            await session.abortTransaction();
            session.endSession();

            // OPTIONAL: Compensate the Keycloak action by deleting the Keycloak user if it was created.
            // (Make sure your KeycloakService.deleteUser method is idempotent and handles missing users gracefully.)
            if (error && error.createdKeycloakUserId) {
                try {
                    await this.keycloakService.deleteUser(keycloakId);
                } catch (compensationError) {
                    // Log the error from the compensation logic
                    console.error('Compensation error:', compensationError.message);
                }
            }
            throw new HttpException(error.message || 'Failed to create user transactionally', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async updateUser(id: string, userDto: any): Promise<any> {
        // Fetch the user from the database to get the associated Keycloak ID
        const dbUser = await this.databaseService.findUserById(id);
        if (!dbUser || !dbUser.keycloakId) {
            throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
        }

        const keycloakId = dbUser.keycloakId;
        const keycloakOGUser = await this.keycloakService.findUserById(keycloakId);

        // Start a Mongoose session
        const session = await this.connection.startSession();
        session.startTransaction();

        try {
            // ---------------------- STEP 1: Keycloak Operation ----------------------
            // Build the payload for Keycloak. Adjust the payload as required by your Keycloak API.
            const keycloakUserPayload = Object.fromEntries(
                Object.entries({
                    username: userDto.username,
                    email: userDto.email,
                    firstName: userDto.firstName,
                    lastName: userDto.lastName,
                    attributes: {
                        phone: userDto.phone,
                        address: userDto.address,
                        cardNumber: userDto.cardNumber,
                        logo: userDto.logo,
                        status: userDto.status || 'pending',
                        // role: userDto.role || keycloakOGUser.attributes.role,
                    },
                }).filter(([_, value]) => value !== undefined && value !== null)
            );

            // Update the user in Keycloak.
            await this.keycloakService.updateUser(keycloakId, keycloakUserPayload);

            const userForDB = { ...userDto, keycloakId: keycloakId };

            // Pass the Mongoose session into the database service to ensure transactionality.
            const updatedUser = await this.databaseService.updateUser(id, userForDB, session);

            // Commit the transaction if both operations succeed.
            await session.commitTransaction();
            session.endSession();
            return updatedUser;
        } catch (error) {
            // Roll back the database changes
            await session.abortTransaction();
            session.endSession();

            // OPTIONAL: Compensate the Keycloak action by reverting the Keycloak user update if necessary.
            if (error && keycloakOGUser) {
                try {
                    // Revert Keycloak changes if needed (implement revert logic in KeycloakService if applicable)
                    await this.keycloakService.updateUser(keycloakId, keycloakOGUser);
                    console.error('Error occurred, consider reverting Keycloak changes if necessary.');
                } catch (compensationError) {
                    console.error('Compensation error:', compensationError.message);
                }
            }
            throw new HttpException(error.message || 'Failed to update user transactionally', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async resetPassword(id: string, newPassword: string): Promise<any> {
        // Fetch the user from the database to get the associated Keycloak ID
        const dbUser = await this.databaseService.findUserById(id);
        if (!dbUser || !dbUser.keycloakId) {
            throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
        }

        const keycloakId = dbUser.keycloakId;
        return this.keycloakService.resetPassword(keycloakId, newPassword);
    }

    async findUserById(id: string): Promise<any> {
        let keycloakUser: any, dbUser: any;

        try {
            dbUser = await this.databaseService.findUserById(id);
        } catch (error) {
            console.error('Database fetch error:', error.message);
            throw new NotFoundException(`User with id ${id} not found in both systems.`);
        }

        try {
            keycloakUser = await this.keycloakService.findUserById(dbUser.keycloakId);
        } catch (error) {
            // Log error but allow fallback
            console.error('Keycloak fetch error:', error.message);
        }


        console.log('Database user:', dbUser);
        console.log('Keycloak user:', keycloakUser);
        // Prioritize Keycloak values if available and merge with database values
        const mergedUser: UserRepresentation = {
            ...dbUser,
            ...keycloakUser,
        };

        return mergedUser;
    }


    async findUserByUsername(username: string): Promise<any> {
        let keycloakUser: any, dbUser: any;

        try {
            dbUser = await this.databaseService.findUserByUsername(username);
        } catch (error) {
            console.error('Database fetch error:', error.message);
            throw new NotFoundException(`User with username ${username} not found in both systems.`);
        }

        try {
            keycloakUser = await this.keycloakService.findUserByUsername(username);
        } catch (error) {
            // Log error but allow fallback
            console.error('Keycloak fetch error:', error.message);
        }

        console.log('Database user:', dbUser);
        console.log('Keycloak user:', keycloakUser);
        // Prioritize Keycloak values if available and merge with database values
        const mergedUser: UserRepresentation = {
            ...dbUser,
            ...keycloakUser,
        };

        return mergedUser;
    }

    async findAllUsersByRole(roleName: string): Promise<any[]> {
        let keycloakUsers: UserRepresentation[] = [];

        try {
            keycloakUsers = await this.keycloakService.findAllUsersByRole(roleName);
            console.log('Keycloak users:', keycloakUsers);
        } catch (error) {
            // Log error but allow fallback
            console.error('Keycloak fetch error:', error.message);
        }

        // let dbUsers: CreateUserDatabaseDto[] = [];

        // try {
        //     dbUsers = await this.databaseService.findAllUsersByRole(roleName);
        // } catch (error) {
        //     console.error('Database fetch error:', error.message);
        //     throw new NotFoundException(`Users with role ${roleName} not found in both systems.`);
        // }

        // console.log('Database users:', dbUsers);

        // Merge users from both sources, prioritizing Keycloak values if available
        // const mergedUsers: UserRepresentation[] = dbUsers.map(dbUser => {
        //     const keycloakUser = keycloakUsers.find(kcUser => kcUser.id === dbUser.keycloakId);
        //     return {
        //         ...dbUser,
        //         ...keycloakUser,
        //     };
        // });

        return keycloakUsers;
    }

    async findAllUsers(): Promise<any[]> {
        let keycloakUsers: any[] = [];
        let dbUsers: any[] = [];

        try {
            dbUsers = await this.databaseService.findAllUsers();
        } catch (error) {
            console.error('Database fetch error:', error.message);
            throw new NotFoundException('Users not found in the database.');
        }

        try {
            keycloakUsers = await this.keycloakService.findAllUsers();
        } catch (error) {
            // Log error but allow fallback
            console.error('Keycloak fetch error:', error.message);
        }

        console.log('Database users:', dbUsers);
        console.log('Keycloak users:', keycloakUsers);

        // Merge users from both sources, prioritizing Keycloak values if available
        const mergedUsers: UserRepresentation[] = dbUsers.map(dbUser => {
            const keycloakUser = keycloakUsers.find(kcUser => kcUser.id === dbUser.keycloakId);
            return {
                ...dbUser,
                ...keycloakUser,
            };
        });

        return mergedUsers;
    }

    async findUserByEmail(email: string): Promise<any> {
        let keycloakUser: any, dbUser: any;

        try {
            dbUser = await this.databaseService.findUserByEmail(email);
        } catch (error) {
            console.error('Database fetch error:', error.message);
            throw new NotFoundException(`User with email ${email} not found in both systems.`);
        }

        try {
            keycloakUser = await this.keycloakService.findUserByEmail(email);
        } catch (error) {
            // Log error but allow fallback
            console.error('Keycloak fetch error:', error.message);
        }

        console.log('Database user:', dbUser);
        console.log('Keycloak user:', keycloakUser);
        // Prioritize Keycloak values if available and merge with database values
        const mergedUser: UserRepresentation = {
            ...dbUser,
            ...keycloakUser,
        };

        return mergedUser;
    }

    async deleteUser(id: string): Promise<any> {
        // Start a Mongoose session
        const session = await this.connection.startSession();
        session.startTransaction();

        try {
            // Fetch the user from the database to get the associated Keycloak ID
            const dbUser = await this.databaseService.findUserById(id);
            if (!dbUser || !dbUser.keycloakId) {
                throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
            }

            const keycloakId = dbUser.keycloakId;

            // Delete the user in Keycloak
            await this.keycloakService.deleteUser(keycloakId);
            console.log('Keycloak user deleted');

            // Pass the Mongoose session into the database service to ensure transactionality
            const deletedUserDB = await this.databaseService.deleteUser(id, session);
            console.log('Database user deleted');

            // Commit the transaction if both operations succeed
            await session.commitTransaction();
            session.endSession();
            return deletedUserDB;
        } catch (error) {
            // Roll back the database changes
            await session.abortTransaction();
            session.endSession();

            // OPTIONAL: Compensate the Keycloak action by recreating the Keycloak user if necessary
            console.error('Error occurred during user deletion:', error.message);
            throw new HttpException(error.message || 'Failed to delete user transactionally', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async assignRole(userId: string, roleName: string): Promise<void> {
        const dbUser = await this.databaseService.findUserById(userId);
        if (!dbUser || !dbUser.keycloakId) {
            throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
        }
        await this.keycloakService.assignRole(dbUser.keycloakId, roleName);
        // // Start a Mongoose session
        // const session = await this.connection.startSession();
        // session.startTransaction();

        // try {
        //     // Use the Keycloak ID to assign the role in Keycloak
        //     await this.keycloakService.assignRole(dbUser.keycloakId, roleName);

        //     // Update the role in the database within the transaction
        //     await this.databaseService.updateUserRole(userId, roleName, true, session);

        //     // Commit the transaction if both operations succeed
        //     await session.commitTransaction();
        //     session.endSession();
        // } catch (error) {
        //     // Roll back the database changes
        //     await session.abortTransaction();
        //     session.endSession();

        //     // Rollback: De-assign role in Keycloak if database update fails
        //     try {
        //         await this.keycloakService.deAssignRole(userId, roleName);
        //     } catch (compensationError) {
        //         console.error('Compensation error:', compensationError.message);
        //     }

        //     throw new HttpException(error.message || 'Failed to assign role transactionally', HttpStatus.INTERNAL_SERVER_ERROR);
        // }
    }

    async deAssignRole(userId: string, roleName: string): Promise<void> {
        const dbUser = await this.databaseService.findUserById(userId);
        if (!dbUser || !dbUser.keycloakId) {
            throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
        }
        await this.keycloakService.deAssignRole(dbUser.keycloakId, roleName);
        // // Start a Mongoose session
        // const session = await this.connection.startSession();
        // session.startTransaction();

        // try {
        //     // Use the Keycloak ID to de-assign the role in Keycloak
        //     await this.keycloakService.deAssignRole(dbUser.keycloakId, roleName);

        //     // Update the role in the database within the transaction
        //     await this.databaseService.updateUserRole(userId, roleName, false, session);

        //     // Commit the transaction if both operations succeed
        //     await session.commitTransaction();
        //     session.endSession();
        // } catch (error) {
        //     // Roll back the database changes
        //     await session.abortTransaction();
        //     session.endSession();

        //     // Rollback: Re-assign role in Keycloak if database update fails
        //     try {
        //         await this.keycloakService.assignRole(dbUser.keycloakId, roleName);
        //     } catch (compensationError) {
        //         console.error('Compensation error:', compensationError.message);
        //     }

        //     throw new HttpException(error.message || 'Failed to de-assign role transactionally', HttpStatus.INTERNAL_SERVER_ERROR);
        // }
    }
}

databaseService:

import { Injectable, NotFoundException } from '@nestjs/common';
import { KeycloakService } from '../keycloak/keycloak.service';
import { CreateUserDatabaseDto, CreateUserDto, UserRepresentation } from '../users/dto/create-user.dto';
import { User, UserDocument } from 'src/users/entities/user.entity';
import { InjectModel } from '@nestjs/mongoose';
import { ClientSession, Model } from 'mongoose';
import { CommonHelpers } from 'src/common/helpers';

@Injectable()
export class DatabaseService {
    constructor(
        @InjectModel(User.name) private readonly UserModel: Model<UserDocument>,
    ) { }

    async createUser(userDto: any, session?: ClientSession): Promise<any> {
        const newUser = Object.fromEntries(
            Object.entries({
                username: userDto.username,
                email: userDto.email,
                // password: userDto.password,
                keycloakId: userDto.keycloakId,
                firstName: userDto.firstName,
                lastName: userDto.lastName,
                phone: userDto.phone,
                address: userDto.address,
                cardNumber: userDto.cardNumber,
                logo: userDto.logo,
                status: userDto.status || 'pending',
                // role: userDto.role,
            }).filter(([_, value]) => value !== undefined && value !== null)
        );

        return CommonHelpers.retry(async () => {
            const createdUser = await this.UserModel.create([newUser], { session });
            // await this.invalidatePartnersCache();
            // console.log('Cache invalidated after create');
            return createdUser;
        });
    }

    async updateUser(id: string, userDto: any, session?: ClientSession): Promise<any> {
        return CommonHelpers.retry(async () => {
            const existingUser = await this.UserModel.findById(id).exec();
            if (!existingUser) {
                throw new NotFoundException('User not found');
            }

            const user = Object.fromEntries(
                Object.entries({
                    username: userDto.username,
                    email: userDto.email,
                    // password: userDto.password,
                    keycloakId: userDto.keycloakId,
                    firstName: userDto.firstName,
                    lastName: userDto.lastName,
                    phone: userDto.phone,
                    address: userDto.address,
                    cardNumber: userDto.cardNumber,
                    logo: userDto.logo,
                    status: userDto.status || 'pending',
                    // role: userDto.role,
                }).filter(([_, value]) => value !== undefined && value !== null)
            );

            const updatedUser = await this.UserModel.findByIdAndUpdate(id, user, { new: true, session }).lean();
            if (!updatedUser) throw new NotFoundException('User not found');
            return updatedUser;
        });
    }

    async updateUserRole2(id: string, roleName: string, addRole: boolean, session?: ClientSession): Promise<any> {
        return CommonHelpers.retry(async () => {
            const user = await this.UserModel.findById(id).exec();
            if (!user) {
                throw new NotFoundException('User not found');
            }
            let updatedUser;

            if (addRole) {
                const newUser = { role: roleName };
                updatedUser = await this.UserModel.findByIdAndUpdate(id, newUser, { new: true, session }).lean();
            } else {
                updatedUser = await this.UserModel.findByIdAndUpdate(id, { role: null }, { new: true, session }).lean();
            }
            return CommonHelpers.transformDocument(updatedUser);
        });
    }


    async findUserById(id: string): Promise<any> {
        try {
            const user = await CommonHelpers.retry(async () => {
                const user = await this.UserModel.findById(id).lean();
                if (!user) {
                    throw new NotFoundException('User not found');
                }
                return user;
            });
            if (!user) {
                throw new NotFoundException('User not found');
            }
            return user;
        } catch (error) {
            throw new Error(`Error finding user by ID: ${error.message}`);
        }
    }

    async findUserByUsername(username: string): Promise<any> {
        try {
            const user = await CommonHelpers.retry(async () => {
                const user = await this.UserModel.findOne({ username }).exec();
                if (!user) {
                    throw new NotFoundException('User not found');
                }
                return user;
            });
            return user;
        } catch (error) {
            throw new Error(`Error finding user by username: ${error.message}`);
        }
    }

    async findAllUsersByRole2(roleName: string, pageOptionsDto?: any): Promise<any[]> {
        try {
            const foundUsers = await CommonHelpers.retry(async () => {
                const users = await this.UserModel.find({ 'role': roleName })
                    .lean()
                    .exec();
                if (!users || users.length === 0) {
                    throw new NotFoundException('No users found for the specified role');
                }
                return users.map(user => CommonHelpers.transformDocument(user));
            });

            // const users = await this.UserModel.find({ 'role': roleName })
            // .limit(pageOptionsDto.take)
            // .skip(pageOptionsDto.skip)
            // .lean()
            // .exec();

            // const items = users.map(user => CommonHelpers.transformDocument(user));
            // const itemCount = await this.UserModel.countDocuments({ [field]: value }).exec();
            // const pageMetaDto = new PageMetaDto({ itemCount, pageOptionsDto });
            // return new PageDto(items, pageMetaDto);
            return foundUsers;
        } catch (error) {
            throw new Error(`Error finding users by role: ${error.message}`);
        }
    }

    async findAllUsers(pageOptionsDto?: any): Promise<UserRepresentation[]> {
        try {
            const users = await CommonHelpers.retry(async () => {
                const users = await this.UserModel.find().lean().exec();
                if (!users || users.length === 0) {
                    throw new NotFoundException('No users found');
                }
                return users;
            });
            const foundUsers = users.map(user => CommonHelpers.transformDocument(user));
            // const users = await this.UserModel.find()
            // .limit(pageOptionsDto.take)
            // .skip(pageOptionsDto.skip)
            // .lean()
            // .exec();

            // const items = users.map(user => CommonHelpers.transformDocument(user));
            // const itemCount = await this.UserModel.countDocuments({ [field]: value }).exec();
            // const pageMetaDto = new PageMetaDto({ itemCount, pageOptionsDto });
            // return new PageDto(items, pageMetaDto);
            return foundUsers;
        } catch (error) {
            throw new Error(`Error finding all users: ${error.message}`);
        }
    }

    async findUserByEmail(email: string): Promise<any> {
        try {
            const user = await CommonHelpers.retry(async () => {
                const user = await this.UserModel.findOne({ email }).exec();
                if (!user) {
                    throw new NotFoundException('User not found');
                }
                return user;
            });
            return user;
        } catch (error) {
            throw new Error(`Error finding user by email: ${error.message}`);
        }
    }

    async deleteUser(id: string, session?: ClientSession) {
        try {
            const result = await CommonHelpers.retry(async () => {
                const user = await this.UserModel.findByIdAndDelete(id, { session }).lean().exec();
                if (!user) {
                    throw new NotFoundException('User not found');
                }
                return user;
            });
            return CommonHelpers.transformDocument(result);
        } catch (error) {
            throw new Error(`Error deleting user: ${error.message}`);
        }
    }
}

keycloakService:

import { BadRequestException, HttpException, HttpStatus, Injectable, UnauthorizedException } from '@nestjs/common';
import KeycloakAdminClient from 'keycloak-admin';
import { HttpService } from "@nestjs/axios";
import { firstValueFrom, lastValueFrom } from "rxjs";
import { RoleRepresentation, UserRepresentation } from 'src/users/dto/create-user.dto';
import { LoginDto } from 'src/users/dto/login.dto';

@Injectable()
export class KeycloakService {

  constructor(
    private readonly httpService: HttpService,) {
  }

  async login(userdto: LoginDto): Promise<any> {
    const url = `${process.env.KEYCLOAK_LOGIN_URL}`;
    const data = new URLSearchParams();
    data.append('grant_type', 'password');
    data.append('client_id', process.env.KEYCLOAK_CLIENT_ID || '');
    data.append('client_secret', process.env.KEYCLOAK_CLIENT_SECRET || '');
    data.append('username', userdto.username);
    data.append('password', userdto.password);

    try {
      const response = await lastValueFrom(
        this.httpService.post(url, data, {
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
        }),
      );
      console.log({ message: 'Login successful', token: response.data.access_token, refreshToken: response.data.refresh_token });
      return response.data; // Contains access_token, refresh_token, etc.
    } catch (error) {
      if (error.response && error.response.status === 401) {
        throw new UnauthorizedException('Invalid credentials');
      }
      throw error; // Propagate other errors
    }
  }

  async logout(refreshToken: string): Promise<void> {
    const url = `${process.env.KEYCLOAK_LOGOUT_URL}`;
    const data = new URLSearchParams();
    data.append('client_id', process.env.KEYCLOAK_CLIENT_ID || '');
    data.append('client_secret', process.env.KEYCLOAK_CLIENT_SECRET || '');
    data.append('token', refreshToken);
    data.append('token_type_hint', 'refresh_token');

    try {
      await lastValueFrom(
        this.httpService.post(url, data, {
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
        }),
      );
      console.log('Logout successful');
    } catch (error) {
      throw error; // Propagate errors for debugging
    }
  }

  async createUser(user: any): Promise<any> {
    // Fetch admin token
    const token = await this.getAdminToken();
    const url = `${process.env.KEYCLOAK_ADMIN_BASE_URL}/users`;

    // Check for existing users
    const existingUserByUsername = await this.findUserByUsername(user.username, token);
    if (existingUserByUsername) {
      throw new BadRequestException(`Username '${user.username}' is already taken.`);
    }

    const existingUserByEmail = await this.findUserByEmail(user.email, token);
    if (existingUserByEmail) {
      throw new BadRequestException(`Email '${user.email}' is already in use.`);
    }
    try {
      const response = await firstValueFrom(
        this.httpService.post(url, user, {
          headers: {
            Authorization: `Bearer ${token}`
          },
        }));
    } catch (error) {
      throw new Error(`Failed to create user: ${error.message}`);
    }

    const createdUser = await this.findUserByUsername(user.username);
    await this.assignRole(createdUser.id, user.attributes.role);
    // await this.keycloakService.sendVerificationEmail(user, token);
    return createdUser;
  }

  async sendVerificationEmail(user: UserRepresentation, token: string) {

    const users = await this.findUserByUsername(user.username, token);
    const userId = users.id;
    const params = new URLSearchParams({
      client_id: `${process.env.KEYCLOAK_CLIENT_ID}`,
      redirect_uri: `${process.env.KEYCLOAK_ADMIN_REDIRECT_URL}`
    });

    try {
      let response = await firstValueFrom(
        this.httpService.post(
          `${process.env.KEYCLOAK_ADMIN_BASE_URL}/users/${userId}/send-verify-email?${params.toString()}`,
          {}, {
          headers: {
            Authorization: `Bearer ${token}`,
            // 'Content-Type': 'application/json'
          },
        }));

    } catch (error) {
      console.error('Send verification email error:', error);
      throw new Error(`Failed to send verification email: ${error.message}`);
    }

  }

  async updateUser(id: string, user: any): Promise<any> {
    const url = `${process.env.KEYCLOAK_ADMIN_BASE_URL}/users/${id}`;

    // const existingUser = await this.findUserById(id);
    // const existingRoles = existingUser.attributes.role || [];

    try {
      await firstValueFrom(
        this.httpService.put(url, user, {
          headers: {
            Authorization: `Bearer ${await this.getAdminToken()}`,
          },
        }),
      );
    } catch (error) {
      throw new Error(`Failed to update user: ${error.message}`);
    }

    // Only assign the role if it has been modified
    // if (user.attributes.role !== existingRoles) {
    //   console.log(`Assigning role: ${user.attributes.role}`);
    //   await this.assignRole(id, user.attributes.role);
    // }

    const updatedUser = await this.findUserById(id);
    return updatedUser;
  }

  async resetPassword(id: string, newPassword: string): Promise<any> {
    const token = await this.getAdminToken();
    const url = `${process.env.KEYCLOAK_ADMIN_BASE_URL}/users/${id}/reset-password`;
    const payload = {
      type: 'password',
      value: newPassword,
      temporary: false, // Set to true if you want to force a password change on next login
    };

    try {
      await firstValueFrom(
        this.httpService.put(url, payload, {
          headers: {
            Authorization: `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
        }),
      );
      // Optionally, fetch and return the updated user
      const updatedUser = await this.findUserById(id);
      return updatedUser;
    } catch (error) {
      console.error('Reset password error response:', error.response?.data);
      throw new HttpException(`Failed to reset password: ${error.message}`, HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }


  async findUserById(id: string, token?: string): Promise<any> {
    if (!token) {
      token = await this.getAdminToken();
    }
    const url = `${process.env.KEYCLOAK_ADMIN_BASE_URL}/users/${id}`;
    try {
      const response = await firstValueFrom(
        this.httpService.get(url, {
          headers: { Authorization: `Bearer ${token}` },
        }),
      );
      return response.data;
    } catch (error) {
      throw new Error(`Failed to find user by id: ${error.message}`);
    }
  }

  // Helper method to find a user by username
  async findUserByUsername(username: string, token?: string): Promise<any> {
    if (!token) {
      token = await this.getAdminToken();
    }
    const url = `${process.env.KEYCLOAK_ADMIN_BASE_URL}/users?username=${username}&exact=true`;
    try {
      const response = await firstValueFrom(
        this.httpService.get(url, {
          headers: { Authorization: `Bearer ${token}` },
        }),
      );
      return response.data.length > 0 ? response.data[0] : null;
    } catch (error) {
      throw new Error(`Failed to find user by username: ${error.message}`);
    }
  }

  async findUserByEmail(email: string, token?: string): Promise<any> {
    if (!token) {
      token = await this.getAdminToken();
    }
    const url = `${process.env.KEYCLOAK_ADMIN_BASE_URL}/users?email=${email}&exact=true`;
    try {
      const response = await firstValueFrom(
        this.httpService.get(url, {
          headers: { Authorization: `Bearer ${token}` },
        }),
      );
      return response.data.length > 0 ? response.data[0] : null;
    } catch (error) {
      throw new Error(`Failed to find user by email: ${error.message}`);
    }
  }

  async findAllUsersByRole(roleName: string, token?: string): Promise<any[]> {
    if (!token) {
      token = await this.getAdminToken();
    }
    const url = `${process.env.KEYCLOAK_ADMIN_BASE_URL}/roles/${roleName}/users`;
    try {
      const response = await firstValueFrom(
        this.httpService.get(url, {
          headers: { Authorization: `Bearer ${token}` },
        }),
      );
      return response.data;
    } catch (error) {
      throw new Error(`Failed to find users by role: ${error.message}`);
    }
  }

  async findAllUsers(): Promise<UserRepresentation[]> {
    const url = `${process.env.KEYCLOAK_ADMIN_BASE_URL}/users`;
    try {
      const response = await firstValueFrom(
        this.httpService.get(url, {
          headers: {
            Authorization: `Bearer ${await this.getAdminToken()}`,
          },
        }),
      );
      return response.data;
    } catch (error) {
      throw new Error(`Failed to find all users: ${error.message}`);
    }
  }

  async deleteUser(id: string): Promise<void> {
    const url = `${process.env.KEYCLOAK_ADMIN_BASE_URL}/users/${id}`;
    try {
      await firstValueFrom(
        this.httpService.delete(url, {
          headers: {
            Authorization: `Bearer ${await this.getAdminToken()}`,
          },
        }),
      );
    } catch (error) {
      throw new Error(`Failed to delete user: ${error.message}`);
    }
  }

  async getRoleByName(name: string, token: string): Promise<RoleRepresentation[]> {
    console.log(`Function: getRoleByName, name: ${name}`);
    const url = `${process.env.KEYCLOAK_ADMIN_BASE_URL}/roles/${name}`;
    try {
      const response = await firstValueFrom(
        this.httpService.get(url, {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }),
      );
      console.log(`Function: getRoleByName, URL: ${url}, Response: ${response.data}`);
      return response.data;
    } catch (error) {
      console.error(`Error in getRoleByName: ${error.message}`);
      throw new Error(`Failed to fetch role by name: ${error.message}`);
    }
  }

  async assignRole(userId: string, roleName: string) {
    console.log(`Function: assignRole, userId: ${userId}, roleName: ${roleName}`);
    const token = await this.getAdminToken();
    const role = await this.getRoleByName(roleName, token);
    const roles = [role];
    console.log(`Function: assignRole, Roles: ${JSON.stringify(roles)}`);
    await firstValueFrom(this.httpService.post(`${process.env.KEYCLOAK_ADMIN_BASE_URL}/users/${userId}/role-mappings/realm`, roles, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    }),

    );
  }

  async deAssignRole(userId: string, roleName: string) {
    const token = await this.getAdminToken();
    const role = await this.getRoleByName(roleName, token);
    const roles = [role];
    await firstValueFrom(this.httpService.delete(`${process.env.KEYCLOAK_ADMIN_BASE_URL}/users/${userId}/role-mappings/realm`, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
      data: roles,
    }),
    );
  }

  async getAdminToken(): Promise<string> {
    const url = process.env.KEYCLOAK_LOGIN_URL || '';

    const formData = new URLSearchParams();
    formData.append('client_id', process.env.KEYCLOAK_CLIENT_ID || '');
    formData.append('client_secret', process.env.KEYCLOAK_CLIENT_SECRET || '');
    formData.append('grant_type', 'client_credentials');
    try {
      const response = await firstValueFrom(
        this.httpService.post(url, formData.toString(), {
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
        }),
      );
      const { access_token } = response.data;
      return access_token;
    } catch (error) {
      throw new Error(`Failed to get admin token: ${error.message}`);
    }
  }

}


user module:

import { Module } from '@nestjs/common';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { KeycloakService } from 'src/keycloak/keycloak.service';
import { HttpModule, HttpService } from '@nestjs/axios';
import { DatabaseService } from 'src/database/database.service';
import { MongooseModule } from '@nestjs/mongoose';
import { User, UserSchema } from './entities/user.entity';
import { TransactionsService } from 'src/transactions/transactions.service';
import { EmailService } from 'src/keycloak/email.service';

@Module({
  imports: [HttpModule,
    MongooseModule.forFeature([{ name: User.name, schema: UserSchema }]),
  ],
  providers: [UsersService, KeycloakService, DatabaseService, TransactionsService, EmailService],
  controllers: [UsersController],
  exports: [UsersService],
})
export class UsersModule {}




the user entity

import { ApiProperty } from '@nestjs/swagger';
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';



export enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  PENDING = 'pending',
}

@Schema({ timestamps: true })
export class User extends Document{
  @Prop({ type: String, required: false })
  @ApiProperty({ description: 'The unique identifier for the user in Keycloak', example: '123e4567-e89b-12d3-a456-426614174000' })
  keycloakId: string;

  @Prop({ type: String, required: true })
  @ApiProperty({ description: 'The username of the user', example: 'johndoe' })
  username: string;

  @Prop({ type: String, required: true })
  @ApiProperty({ description: 'The email address of the user', example: 'johndoe@example.com' })
  email: string;

  // @Prop({ type: String, required: true })
  // @ApiProperty({ description: 'The password of the user', example: 'P@ssw0rd' })
  // password: string;

  @Prop({ type: String, required: false })
  @ApiProperty({ description: 'The first name of the user', example: 'John', required: false })
  firstName?: string;

  @Prop({ type: String, required: false })
  @ApiProperty({ description: 'The last name of the user', example: 'Doe', required: false })
  lastName?: string;

  @Prop({ type: String, required: false })
  @ApiProperty({ description: 'The phone number of the user', example: '+1234567890', required: false })
  phone?: string;

  @Prop({ type: String, required: false })
  @ApiProperty({ description: 'The address of the user', example: '123 Main St, Springfield', required: false })
  address?: string;

  @Prop({ type: String, required: false })
  @ApiProperty({ description: 'The card number associated with the user', example: '4111111111111111', required: false })
  cardNumber?: string;

  @Prop({ type: String, required: false })
  @ApiProperty({ description: 'The logo or avatar of the user', example: 'https://example.com/logo.png', required: false })
  logo?: string;

  @Prop({ type: String, enum: UserStatus, required: false })
  @ApiProperty({ description: 'The status of the user', example: 'active', default: 'active', required: false })
  status?: UserStatus;

  // @Prop({ type: String, required: true })
  // @ApiProperty({ description: 'The role of the user', example: 'admin' })
  // role: string;
}

export type UserDocument = User & Document;

export const UserSchema = SchemaFactory.createForClass(User);

the email service:

import { Injectable, Logger } from '@nestjs/common';
import * as nodemailer from 'nodemailer';
import * as handlebars from 'handlebars';
import * as fs from 'fs';
import * as path from 'path';

@Injectable()
export class EmailService {
    private transporter: nodemailer.Transporter;
    private confirmationTemplate: handlebars.TemplateDelegate;

    constructor() {
        this.transporter = nodemailer.createTransport(
            {
                service: "gmail",
                host: "smtp.gmail.com",
                port: Number(465),
                secure: true,
                auth: {
                    user: "sammynegalbert@gmail.com",
                    pass: "ofvmompziweobxsd",
                },
                tls: { rejectUnauthorized: false }
            },
            {
                from: {
                    name: 'Asyst Waangu Marketplace',
                    address: `ASYST Burundi `,
                },
            },
        );
        // Load Handlebars templates
        this.confirmationTemplate = this.loadTemplate('template.hbs');
    }

    private loadTemplate(templateName: string): handlebars.TemplateDelegate {
        const templatesFolderPath = path.join('src/resource/template');
        const templatePath = path.join(templatesFolderPath, templateName);

        const templateSource = fs.readFileSync(templatePath, 'utf8');
        return handlebars.compile(templateSource);
    }

    async sendVerificationEmail(to: string, link: string): Promise<void> {
        await this.transporter.sendMail({
          from: '"Your App" <no-reply@yourapp.com>',
          to,
          subject: 'Verify Your Account',
          html: `
            <p>Thanks for signing up!</p>
            <p>Please click the link below to verify your account:</p>
            <a href="${link}">${link}</a>
          `,
        });
      }

    async sendUserConfirmation(user: string, token: string) {
        const nif = token;
        const html = this.confirmationTemplate({ message: "Vous venez de creer le nouveau compte ! et voici votre mot de passe:" + nif });
        await this.transporter.sendMail({
            to: user,
            subject: 'Welcome user! Confirm your Email',
            html: html,
        });
    }
}

so the modification i want are:
first i want a user to login with username or email and password
second add security to routes by role for example assign a role or deassign a role should be done just by an admin
add a verification email stuffs using keycloak, correct my codes but use the logic i tried and merge it with ur own
show me an example how it works nd highlights wherever you changed in the codes



