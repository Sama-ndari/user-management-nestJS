[
    {
        "role": "Admin",
        "username": "admin_user1",
        "email": "admin1@example.com",
        "password": "AdminPass123"
    },
    {
        "role": "Admin",
        "username": "admin_user2",
        "email": "admin2@example.com",
        "password": "AdminPass456"
    },
    {
        "role": "Admin",
        "username": "admin_user3",
        "email": "admin3@example.com",
        "password": "AdminPass789"
    },
    {
        "role": "Admin",
        "username": "admin_user4",
        "email": "admin4@example.com",
        "password": "AdminPass101"
    },
    {
        "role": "Admin",
        "username": "admin_user5",
        "email": "admin5@example.com",
        "password": "AdminPass202"
    },
    {
        "role": "Customer",
        "username": "customer_user1",
        "firstName": "John",
        "lastName": "Doe",
        "email": "customer1@example.com",
        "password": "CustPass123",
        "cardNumber": "4111111111111111",
        "address": "123 Elm St, Springfield, USA",
        "logo": "https://example.com/logo1.png"
    },
    {
        "role": "Customer",
        "username": "customer_user2",
        "firstName": "Jane",
        "lastName": "Smith",
        "email": "customer2@example.com",
        "password": "CustPass456",
        "cardNumber": "4111111111112222",
        "address": "456 Oak St, Springfield, USA",
        "logo": "https://example.com/logo2.png"
    },
    {
        "role": "Customer",
        "username": "customer_user3",
        "firstName": "Alice",
        "lastName": "Johnson",
        "email": "customer3@example.com",
        "password": "CustPass789",
        "cardNumber": "4111111111113333",
        "address": "789 Pine St, Springfield, USA",
        "logo": "https://example.com/logo3.png"
    },
    {
        "role": "Customer",
        "username": "customer_user4",
        "firstName": "Bob",
        "lastName": "Brown",
        "email": "customer4@example.com",
        "password": "CustPass101",
        "cardNumber": "4111111111114444",
        "address": "101 Maple St, Springfield, USA",
        "logo": "https://example.com/logo4.png"
    },
    {
        "role": "Customer",
        "username": "customer_user5",
        "firstName": "Charlie",
        "lastName": "White",
        "email": "customer5@example.com",
        "password": "CustPass202",
        "cardNumber": "4111111111115555",
        "address": "202 Birch St, Springfield, USA",
        "logo": "https://example.com/logo5.png"
    },
    {
        "role": "Merchant",
        "username": "merchant_user1",
        "firstName": "David",
        "lastName": "Green",
        "email": "merchant1@example.com",
        "password": "MerchPass123",
        "phone": "123-456-7890",
        "address": "123 Cedar St, Springfield, USA",
        "logo": "https://example.com/logo6.png",
        "status": "active"
    },
    {
        "role": "Merchant",
        "username": "merchant_user2",
        "firstName": "Eve",
        "lastName": "Black",
        "email": "merchant2@example.com",
        "password": "MerchPass456",
        "phone": "234-567-8901",
        "address": "456 Walnut St, Springfield, USA",
        "logo": "https://example.com/logo7.png",
        "status": "inactive"
    },
    {
        "role": "Merchant",
        "username": "merchant_user3",
        "firstName": "Frank",
        "lastName": "Blue",
        "email": "merchant3@example.com",
        "password": "MerchPass789",
        "phone": "345-678-9012",
        "address": "789 Chestnut St, Springfield, USA",
        "logo": "https://example.com/logo8.png",
        "status": "active"
    },
    {
        "role": "Merchant",
        "username": "merchant_user4",
        "firstName": "Grace",
        "lastName": "Yellow",
        "email": "merchant4@example.com",
        "password": "MerchPass101",
        "phone": "456-789-0123",
        "address": "101 Poplar St, Springfield, USA",
        "logo": "https://example.com/logo9.png",
        "status": "inactive"
    },
    {
        "role": "Merchant",
        "username": "merchant_user5",
        "firstName": "Hank",
        "lastName": "Red",
        "email": "merchant5@example.com",
        "password": "MerchPass202",
        "phone": "567-890-1234",
        "address": "202 Willow St, Springfield, USA",
        "logo": "https://example.com/logo10.png",
        "status": "active"
    },
    {
        "role": "Commissionaire",
        "username": "comm_user1",
        "firstName": "Ivy",
        "lastName": "Orange",
        "email": "comm1@example.com",
        "password": "CommPass123",
        "phone": "678-901-2345",
        "address": "123 Fir St, Springfield, USA",
        "logo": "https://example.com/logo11.png"
    },
    {
        "role": "Commissionaire",
        "username": "comm_user2",
        "firstName": "Jack",
        "lastName": "Purple",
        "email": "comm2@example.com",
        "password": "CommPass456",
        "phone": "789-012-3456",
        "address": "456 Spruce St, Springfield, USA",
        "logo": "https://example.com/logo12.png"
    },
    {
        "role": "Commissionaire",
        "username": "comm_user3",
        "firstName": "Karen",
        "lastName": "Pink",
        "email": "comm3@example.com",
        "password": "CommPass789",
        "phone": "890-123-4567",
        "address": "789 Redwood St, Springfield, USA",
        "logo": "https://example.com/logo13.png"
    },
    {
        "role": "Commissionaire",
        "username": "comm_user4",
        "firstName": "Leo",
        "lastName": "Gray",
        "email": "comm4@example.com",
        "password": "CommPass101",
        "phone": "901-234-5678",
        "address": "101 Cypress St, Springfield, USA",
        "logo": "https://example.com/logo14.png"
    },
    {
        "role": "Commissionaire",
        "username": "comm_user5",
        "firstName": "Mia",
        "lastName": "Brown",
        "email": "comm5@example.com",
        "password": "CommPass202",
        "phone": "012-345-6789",
        "address": "202 Ash St, Springfield, USA",
        "logo": "https://example.com/logo15.png"
    }
]
julesAsyst: async createGroup(groupName: string, attributes?: Record<string, any>): Promise<void> {
    const token = await this.getAdminToken();
    const url = `${process.env.KEYCLOAK_ADMIN_BASE_URL}/groups`;
    const payload = {
      name: groupName,
      attributes: attributes || {},
    };

    try {
      await firstValueFrom(
        this.httpService.post(url, payload, {
          headers: {
            Authorization: `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
        }),
      );
      console.log(`Group '${groupName}' created successfully.`);
    } catch (error) {
      throw new HttpException(`Failed to create group: ${error.message}`, HttpStatus.INTERNAL_SERVER_ERROR);
    }
  give me an example of a dto when creating a group what do we take on attributes

GitHub Copilot: The `attributes` field in the `CreateGroupDto` is defined as an optional `Record<string, any>`. This means it can hold key-value pairs where the keys are strings, and the values can be of any type. Here's an example of a DTO when creating a group:

```typescript
// Example DTO for creating a group
const createGroupDto: CreateGroupDto = {
  name: "Admins",
  attributes: {
    description: "Group for admin users",
    createdBy: "system",
    permissions: ["read", "write", "delete"],
    isActive: true,
  },
};
```

### Explanation:
- **`name`**: The name of the group (e.g., "Admins").
- **`attributes`**: A set of metadata or additional properties for the group. In this example:
  - `description`: A string describing the group.
  - `createdBy`: A string indicating who created the group.
  - `permissions`: An array of strings representing permissions associated with the group.
  - `isActive`: A boolean indicating whether the group is active.

You can customize the `attributes` object based on your application's requirements.

julesAsyst: What other attributes can we use?

GitHub Copilot: Here are some additional attributes you can consider for the `CreateGroupDto` based on common use cases for groups in applications:

```typescript
export class CreateGroupDto {
    name: string;
    attributes?: Record<string, any>;
}

// Example attributes you can use:
const exampleAttributes = {
    description: "A detailed description of the group", // A string describing the group
    createdBy: "adminUser123", // The user who created the group
    createdAt: new Date().toISOString(), // Timestamp of when the group was created
    updatedAt: new Date().toISOString(), // Timestamp of the last update
    permissions: ["read", "write", "delete"], // Array of permissions associated with the group
    isActive: true, // Boolean indicating if the group is active
    maxMembers: 100, // Maximum number of members allowed in the group
    tags: ["admin", "management"], // Array of tags for categorization
    priority: 1, // Numeric priority level for the group
    customField1: "Custom value", // Any custom field specific to your application
    customField2: 42, // Another custom field with a numeric value
};
```

### Explanation of Attributes:
1. **`description`**: Provides a human-readable description of the group.
2. **`createdBy`**: Tracks the user or system that created the group.
3. **`createdAt` / `updatedAt`**: Timestamps for auditing purposes.
4. **`permissions`**: Defines the actions the group is allowed to perform.
5. **`isActive`**: Indicates whether the group is currently active or inactive.
6. **`maxMembers`**: Limits the number of members in the group.
7. **`tags`**: Helps categorize or label the group for easier filtering or searching.
8. **`priority`**: Assigns a priority level to the group (useful for sorting or processing).
9. **`customField1`, `customField2`**: Placeholder fields for any application-specific data.

You can adapt these attributes based on your application's requirements and the context in which groups are used.

julesAsyst: hello i somehow managed to track what the user do but I just tested on getAllUser but there is a problem
the controller:
@Get()
  @ApiOperation({ summary: 'Find all users' })
  // @UseGuards(AuthGuard('jwt'))
  @Roles({ roles: ['Admin','Customer','Merchant','Commissionaire'] })  
  async findAll(@Query() pageOptionsDto: PageOptionsDto) {
    console.log('Request received in controller, user:', req.user);
    const users = await this.usersService.findAllUsers(pageOptionsDto);
    console.log('Users fetched:', users);
    return users;
  }

the service:
 async findAllUsers(): Promise<UserRepresentation[]> {
    const url = `${process.env.KEYCLOAK_ADMIN_BASE_URL}/users`;
    const token = await this.getAdminToken();
    try {
      const response = await firstValueFrom(
        this.httpService.get(url, { headers: { Authorization: `Bearer ${token}` } }),
      );
      console.log('response', response);
      const users = response.data;
      const userRoles = await Promise.all(users.map(user => this.getUserRole(user.id, token)));
      const userGroups = await Promise.all(users.map(user => this.getUserGroups(user.id, token)));
      users.forEach((user, index) => {
        user.roles = userRoles[index];
        user.groups = userGroups[index];
      });
      this.loggerService.logAction('LIST_USERS', users, { users: users });
      return users;
    } catch (error) {
      throw new HttpException(`Find all users failed: ${error.message}`, HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

the logger.service:
import { Injectable, Scope, Inject } from '@nestjs/common';
import { REQUEST } from '@nestjs/core';
import * as winston from 'winston';

@Injectable({ scope: Scope.REQUEST })
export class LoggerService {
  private logger: winston.Logger;

  constructor(@Inject(REQUEST) private readonly request: any) {
    this.logger = winston.createLogger({
      level: 'info',
      format: winston.format.json(),
      transports: [
        new winston.transports.File({ filename: 'logs/audit.log' }),
      ],
    });
  }

  logAction(action: string, target: any, details?: any) {
    const actor = this.request?.user?.username || 'system'; // Fallback to 'system' if no user
    console.log('actor', this.request?.user?.username);
    const logEntry = {
      timestamp: new Date().toISOString(),
      action,
      actor,
      target,
      details,
    };
    this.logger.info(logEntry);
  }
}

the jwtStrategy service:
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import * as jwksRsa from 'jwks-rsa';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKeyProvider: jwksRsa.passportJwtSecret({
        cache: true,
        rateLimit: true,
        jwksRequestsPerMinute: 5,
        jwksUri: `${process.env.KEYCLOAK_AUTH_SERVER_URL}/realms/${process.env.KEYCLOAK_REALM}/protocol/openid-connect/certs`,
      }),
    });
  }

  async validate(payload: any) {
    console.log('Validating payload:', payload); // Add for debugging
    return { userId: payload.sub, username: payload.preferred_username };
  }
}

in the controller when I comment the "@UseGuards(AuthGuard('jwt'))" decorator it works perfectly I see data both in console'log of my controller and it returns it both in swagger without a loggedin user and in the frontend when a user is logged in but in the audit.log file the actor remain system I don't get the connected user data.username

and when I uncomment it in the audit.log I get the user data.username perfectly and the console.log in the controller  works fine but in swagger I get an unauthorised error and in the frontend when a user is connected I get a 403 error

help me and explain it whats the issue and how to fix it simple without bothering the frontend???
and help me how i can get the data in the audit.log i want to just send data to the frontend

Workspace: Enable GPT-4.1 (Preview) for all clients
Enable access to the latest GPT-4.1 model from OpenAI. [Learn more about how GitHub Copilot serves GPT-4.1](https://docs.github.com/en/copilot/using-github-copilot/ai-models/choosing-the-right-ai-model-for-your-task#gpt-41).

julesAsyst: @workspace Enable: "Enable GPT-4.1 (Preview) for all clients"

Workspace: Collecting workspace informationYou are facing two issues:

1. **When `@UseGuards(AuthGuard('jwt'))` is commented out:**  
   - The endpoint works for everyone (Swagger, frontend, unauthenticated users).
   - But `actor` in the audit log is always `"system"` because there is no authenticated user in the request context.

2. **When `@UseGuards(AuthGuard('jwt'))` is enabled:**  
   - The endpoint only works for authenticated users with a valid JWT.
   - The audit log correctly records the username.
   - But Swagger (unless you provide a valid JWT in the "Authorize" button) and unauthenticated frontend users get 401/403 errors.

---

## Why does this happen?

- **NestJS `@UseGuards(AuthGuard('jwt'))`** protects the route, requiring a valid JWT token.  
- If you don't send a token, NestJS does not populate `req.user`, so your logger falls back to `"system"`.
- If you do send a token, `req.user` is set, and the logger works, but unauthenticated requests are blocked.

---

## How to fix this (simple, no frontend change):

### 1. **For Swagger:**
- Use the "Authorize" button in Swagger UI to provide a valid JWT token.  
- You can get a token by logging in (using your `/users/login` endpoint) and copying the `access_token` into Swagger.

### 2. **For the frontend:**
- Make sure the frontend sends the JWT token in the `Authorization: Bearer <token>` header for all protected endpoints.

### 3. **If you want to allow unauthenticated access but still log the user if present:**
- Use a **custom guard** or the built-in [`@Optional()`](https://docs.nestjs.com/custom-decorators#optional-parameters) pattern, but this is not recommended for sensitive endpoints.
- Or, **remove the guard** and accept that you will only log `"system"` for unauthenticated users.

---

## **Summary Table**

| Scenario                | Guard Enabled | JWT Required | Actor in Log | Works in Swagger w/o JWT | Works in Frontend w/o JWT |
|-------------------------|--------------|--------------|--------------|-------------------------|--------------------------|
| Secure (recommended)    | Yes          | Yes          | Username     | No                      | No                       |
| Open (not recommended)  | No           | No           | "system"     | Yes                     | Yes                      |

---

## **Best Practice**

- **Keep the guard enabled.**
- **Educate frontend and Swagger users to provide a JWT.**
- If you want to test in Swagger, always use the "Authorize" button with a valid token.

---

## **How to always get the actor in the audit log?**

- You must have a valid JWT in the request.  
- There is no way to get the username for unauthenticated requests.

---

## **How to just send data to the frontend?**

- Your current controller already returns the users:
  ```typescript
  // filepath: src/users/users.controller.ts
  @Get()
  @ApiOperation({ summary: 'Find all users' })
  @UseGuards(AuthGuard('jwt'))
  @Roles({ roles: ['Admin','Customer','Merchant','Commissionaire'] })
  async findAll(@Query() pageOptionsDto: PageOptionsDto, @Request() req) {
    console.log('Request received in controller, user:', req.user);
    const users = await this.usersService.findAllUsers(pageOptionsDto);
    console.log('Users fetched:', users);
    return users;
  }
  ```
- Make sure the frontend sends the JWT in the request header.

---

**In summary:**  
You must use JWT authentication to get the username in the audit log. If you want to test in Swagger, use the "Authorize" button. The frontend must always send the JWT. There is no way to get the username for unauthenticated requests.

See `LoggerService` and `JwtStrategy` for details.

julesAsyst: @Get('logs/audit')
  getAuditLog(@Res() res: Response) {
    const logFilePath = path.join(__dirname, '..', '..', 'logs', 'audit.log');
    if (fs.existsSync(logFilePath)) {
      res.sendFile(logFilePath);
    } else {
      res.status(404).send('Log file not found');
    }
  }

  when i get the audit.log
  {
  "statusCode": 403,
  "message": "Cannot read properties of undefined (reading 'join')",
  "timestamp": "2025-04-30T07:05:37.441Z"
}

why the error i want to get just data in the audit.log file as a json file

GitHub Copilot: The error `"Cannot read properties of undefined (reading 'join')"` means that `path` is `undefined` in your controller. This happens because you are importing `path` like this:

```typescript
import path from 'path';
```

But in Node.js (and TypeScript), you should import it as:

```typescript
import * as path from 'path';
```

---

## **How to fix**

Change your import at the top of your controller file:

````typescript
// ...existing code...
import * as path from 'path';
// ...existing code...
````

---

## **Additionally: Return JSON content**

If you want to return the audit log as JSON, read the file and parse each line as JSON:

````typescript
@Get('logs/audit')
async getAuditLog(@Res() res: Response) {
  const logFilePath = path.join(__dirname, '..', '..', 'logs', 'audit.log');
  if (fs.existsSync(logFilePath)) {
    const data = fs.readFileSync(logFilePath, 'utf-8');
    // Each log entry is a JSON object per line
    const logs = data
      .split('\n')
      .filter(line => line.trim() !== '')
      .map(line => {
        try {
          return JSON.parse(line);
        } catch {
          return { raw: line };
        }
      });
    res.json(logs);
  } else {
    res.status(404).send('Log file not found');
  }
}
````

---

**Summary:**  
- Change your `path` import to `import * as path from 'path';`
- Use the above code to return the audit log as JSON.

julesAsyst: it works now add a filter in the controller by date(year-month-date) or by actor, or byaction
and divide make the service for it and a controller for it

GitHub Copilot: Certainly! Here’s how you can add filtering by date (year-month-day), actor, or action in a typical Spring Boot application. I’ll provide:

- **Service Layer**: Methods to filter by date, actor, or action.
- **Controller Layer**: Endpoints to call those service methods.
- **Assumptions**:  
  - You have an `Activity` entity with fields: `LocalDate date`, `String actor`, `String action`.
  - You have an `ActivityRepository` that extends `JpaRepository<Activity, Long>`.

---

## 1. Service Layer

```java
@Service
public class ActivityService {

    @Autowired
    private ActivityRepository activityRepository;

    public List<Activity> filterByDate(LocalDate date) {
        return activityRepository.findByDate(date);
    }

    public List<Activity> filterByActor(String actor) {
        return activityRepository.findByActor(actor);
    }

    public List<Activity> filterByAction(String action) {
        return activityRepository.findByAction(action);
    }
}
```

---

## 2. Repository Layer

Add these methods to your repository:

```java
public interface ActivityRepository extends JpaRepository<Activity, Long> {
    List<Activity> findByDate(LocalDate date);
    List<Activity> findByActor(String actor);
    List<Activity> findByAction(String action);
}
```

---

## 3. Controller Layer

```java
@RestController
@RequestMapping("/activities")
public class ActivityController {

    @Autowired
    private ActivityService activityService;

    @GetMapping("/filter")
    public List<Activity> filterActivities(
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date,
            @RequestParam(required = false) String actor,
            @RequestParam(required = false) String action) {

        if (date != null) {
            return activityService.filterByDate(date);
        } else if (actor != null) {
            return activityService.filterByActor(actor);
        } else if (action != null) {
            return activityService.filterByAction(action);
        } else {
            // Return all or throw error
            return new ArrayList<>();
        }
    }
}
```

---

## 4. Example Requests

- Filter by date:  
  `GET /activities/filter?date=2024-06-10`
- Filter by actor:  
  `GET /activities/filter?actor=John`
- Filter by action:  
  `GET /activities/filter?action=LOGIN`

---

**You can extend this to combine filters if needed. Let me know if you want that!**

julesAsyst:  
  @Get('logs/audit')
async getAuditLog(@Res() res: Response) {
    const logFilePath = path.join(__dirname, '..', '..', 'logs', 'audit.log');
    if (fs.existsSync(logFilePath)) {
      const data = fs.readFileSync(logFilePath, 'utf-8');
      // Each log entry is a JSON object per line
      const logs = data
        .split('\n')
        .filter(line => line.trim() !== '')
        .map(line => {
          try {
            return JSON.parse(line);
          } catch {
            return { raw: line };
          }
        });
      res.json(logs);
    } else {
      res.status(404).send('Log file not found');
    }
  }
  it works now add a filter in the controller by date(year-month-date) or by actor, or byaction
and divide make the service for it and a controller for it

{
  "level": "info",
  "message": {
    "action": "LIST_USERS",
    "actor": "system",
    "details": {
      "users": [
        {
          "access": {
            "impersonate": true,
            "manage": true,
            "manageGroupMembership": true,
            "mapRoles": true,
            "view": true
          },
          "attributes": {
            "address": [
              "Bwiza 5 av, N35"
            ],
            "cardNumber": [
              "A84946949479"
            ],
            "group": [
              "Admin Superieur"
            ],
            "logo": [
              "images/0c177bde-f990-40ce-9835-07f96aaa7541.jpg"
            ],
            "phone": [
              "77500625"
            ],
            "status": [
              "active"
            ]
          },
          "createdTimestamp": 1745939331929,
          "disableableCredentialTypes": [],
          "email": "christiankatshuva@gmail.com",
          "emailVerified": false,
          "enabled": true,
          "firstName": "Christian",
          "groups": [
            {
              "id": "238ef06a-6de7-4d36-9d12-c644217fa938",
              "name": "Admin Superieur",
              "path": "/Admin Superieur"
            }
          ],
          "id": "af13aef9-6f1e-44db-804f-4cd29ac3b9ef",
          "lastName": "Katshuva",
          "notBefore": 0,
          "requiredActions": [],
          "roles": [
            {
              "clientRole": false,
              "composite": true,
              "containerId": "Waangu-Marketplace",
              "description": "${role_default-roles}",
              "id": "a2dfd83a-4d95-4bb5-8cd7-066d4cb222ff",
              "name": "Commandes"
            }
          ],
          "totp": false,
          "username": "chriskatsh"
        },
        {
          "access": {
            "impersonate": true,
            "manage": true,
            "manageGroupMembership": true,
            "mapRoles": true,
            "view": true
          },
          "attributes": {
            "status": [
              "pending"
            ]
          },
          "createdTimestamp": 1745566641096,
          "disableableCredentialTypes": [],
          "email": "racheva1671@gmail.com",
          "emailVerified": false,
          "enabled": true,
          "firstName": "",
          "groups": [],
          "id": "8cc46874-9525-483c-be10-7df733ef226c",
          "lastName": "",
          "notBefore": 0,
          "requiredActions": [],
          "roles": [
            {
              "clientRole": false,
              "composite": false,
              "containerId": "Waangu-Marketplace",
              "description": "un marchand",
              "id": "e1b1eeeb-a72b-4d9a-a311-7b7b3bccf6f5",
              "name": "Merchant"
            },
            {
              "clientRole": false,
              "composite": true,
              "containerId": "Waangu-Marketplace",
              "description": "${role_default-roles}",
              "id": "a2dfd83a-4d95-4bb5-8cd7-066d4cb222ff",
              "name": "Commandes"
            }
          ],
          "totp": false,
          "username": "johncena"
        },
        {
          "access": {
            "impersonate": true,
            "manage": true,
            "manageGroupMembership": true,
            "mapRoles": true,
            "view": true
          },
          "attributes": {
            "address": [
              "Rome"
            ],
            "logo": [
              "images/4bc39b17-3f58-4f2e-9f26-a972f19c33da.jpg"
            ],
            "phone": [
              "77500625"
            ],
            "status": [
              "pending"
            ]
          },
          "createdTimestamp": 1745749594795,
          "disableableCredentialTypes": [],
          "email": "johndoe@example.com",
          "emailVerified": false,
          "enabled": true,
          "firstName": "Jules",
          "groups": [
            {
              "id": "869851b4-a2df-4383-a3b0-692109de3ffa",
              "name": "Commissionaire",
              "path": "/Commissionaire"
            }
          ],
          "id": "725347db-9710-40af-8863-e130d664e7aa",
          "lastName": "Cesars",
          "notBefore": 0,
          "requiredActions": [],
          "roles": [
            {
              "clientRole": false,
              "composite": true,
              "containerId": "Waangu-Marketplace",
              "description": "${role_default-roles}",
              "id": "a2dfd83a-4d95-4bb5-8cd7-066d4cb222ff",
              "name": "Commandes"
            }
          ],
          "totp": false,
          "username": "johndoe"
        },
        {
          "access": {
            "impersonate": true,
            "manage": true,
            "manageGroupMembership": true,
            "mapRoles": true,
            "view": true
          },
          "attributes": {
            "address": [
              "Bwiza 5 av, N35"
            ],
            "logo": [
              "images/4e78f6e0-c8ab-4099-b9a8-05e59fe35ce5.jpg"
            ],
            "phone": [
              "62617491"
            ],
            "status": [
              "active"
            ]
          },
          "createdTimestamp": 1745825538746,
          "disableableCredentialTypes": [],
          "email": "katshuvachristian@gmail.com",
          "emailVerified": false,
          "enabled": true,
          "firstName": "Katshuva",
          "groups": [
            {
              "id": "4daa01b1-46c1-40fe-a8ad-1a19eafceb7e",
              "name": "Admin",
              "path": "/Admin"
            }
          ],
          "id": "cd50ab90-d08f-481d-ba68-068467c4fb1f",
          "lastName": "Christian",
          "notBefore": 0,
          "requiredActions": [],
          "roles": [
            {
              "clientRole": false,
              "composite": true,
              "containerId": "Waangu-Marketplace",
              "description": "${role_default-roles}",
              "id": "a2dfd83a-4d95-4bb5-8cd7-066d4cb222ff",
              "name": "Commandes"
            },
            {
              "clientRole": false,
              "composite": false,
              "containerId": "Waangu-Marketplace",
              "description": "l'administrateur",
              "id": "535216b8-2870-44fb-8fbb-a498d585ba20",
              "name": "Administrateur"
            }
          ],
          "totp": false,
          "username": "katshchris2105"
        }
      ]
    },
    "target": [
      {
        "access": {
          "impersonate": true,
          "manage": true,
          "manageGroupMembership": true,
          "mapRoles": true,
          "view": true
        },
        "attributes": {
          "address": [
            "Bwiza 5 av, N35"
          ],
          "cardNumber": [
            "A84946949479"
          ],
          "group": [
            "Admin Superieur"
          ],
          "logo": [
            "images/0c177bde-f990-40ce-9835-07f96aaa7541.jpg"
          ],
          "phone": [
            "77500625"
          ],
          "status": [
            "active"
          ]
        },
        "createdTimestamp": 1745939331929,
        "disableableCredentialTypes": [],
        "email": "christiankatshuva@gmail.com",
        "emailVerified": false,
        "enabled": true,
        "firstName": "Christian",
        "groups": [
          {
            "id": "238ef06a-6de7-4d36-9d12-c644217fa938",
            "name": "Admin Superieur",
            "path": "/Admin Superieur"
          }
        ],
        "id": "af13aef9-6f1e-44db-804f-4cd29ac3b9ef",
        "lastName": "Katshuva",
        "notBefore": 0,
        "requiredActions": [],
        "roles": [
          {
            "clientRole": false,
            "composite": true,
            "containerId": "Waangu-Marketplace",
            "description": "${role_default-roles}",
            "id": "a2dfd83a-4d95-4bb5-8cd7-066d4cb222ff",
            "name": "Commandes"
          }
        ],
        "totp": false,
        "username": "chriskatsh"
      },
      {
        "access": {
          "impersonate": true,
          "manage": true,
          "manageGroupMembership": true,
          "mapRoles": true,
          "view": true
        },
        "attributes": {
          "status": [
            "pending"
          ]
        },
        "createdTimestamp": 1745566641096,
        "disableableCredentialTypes": [],
        "email": "racheva1671@gmail.com",
        "emailVerified": false,
        "enabled": true,
        "firstName": "",
        "groups": [],
        "id": "8cc46874-9525-483c-be10-7df733ef226c",
        "lastName": "",
        "notBefore": 0,
        "requiredActions": [],
        "roles": [
          {
            "clientRole": false,
            "composite": false,
            "containerId": "Waangu-Marketplace",
            "description": "un marchand",
            "id": "e1b1eeeb-a72b-4d9a-a311-7b7b3bccf6f5",
            "name": "Merchant"
          },
          {
            "clientRole": false,
            "composite": true,
            "containerId": "Waangu-Marketplace",
            "description": "${role_default-roles}",
            "id": "a2dfd83a-4d95-4bb5-8cd7-066d4cb222ff",
            "name": "Commandes"
          }
        ],
        "totp": false,
        "username": "johncena"
      },
      {
        "access": {
          "impersonate": true,
          "manage": true,
          "manageGroupMembership": true,
          "mapRoles": true,
          "view": true
        },
        "attributes": {
          "address": [
            "Rome"
          ],
          "logo": [
            "images/4bc39b17-3f58-4f2e-9f26-a972f19c33da.jpg"
          ],
          "phone": [
            "77500625"
          ],
          "status": [
            "pending"
          ]
        },
        "createdTimestamp": 1745749594795,
        "disableableCredentialTypes": [],
        "email": "johndoe@example.com",
        "emailVerified": false,
        "enabled": true,
        "firstName": "Jules",
        "groups": [
          {
            "id": "869851b4-a2df-4383-a3b0-692109de3ffa",
            "name": "Commissionaire",
            "path": "/Commissionaire"
          }
        ],
        "id": "725347db-9710-40af-8863-e130d664e7aa",
        "lastName": "Cesars",
        "notBefore": 0,
        "requiredActions": [],
        "roles": [
          {
            "clientRole": false,
            "composite": true,
            "containerId": "Waangu-Marketplace",
            "description": "${role_default-roles}",
            "id": "a2dfd83a-4d95-4bb5-8cd7-066d4cb222ff",
            "name": "Commandes"
          }
        ],
        "totp": false,
        "username": "johndoe"
      },
      {
        "access": {
          "impersonate": true,
          "manage": true,
          "manageGroupMembership": true,
          "mapRoles": true,
          "view": true
        },
        "attributes": {
          "address": [
            "Bwiza 5 av, N35"
          ],
          "logo": [
            "images/4e78f6e0-c8ab-4099-b9a8-05e59fe35ce5.jpg"
          ],
          "phone": [
            "62617491"
          ],
          "status": [
            "active"
          ]
        },
        "createdTimestamp": 1745825538746,
        "disableableCredentialTypes": [],
        "email": "katshuvachristian@gmail.com",
        "emailVerified": false,
        "enabled": true,
        "firstName": "Katshuva",
        "groups": [
          {
            "id": "4daa01b1-46c1-40fe-a8ad-1a19eafceb7e",
            "name": "Admin",
            "path": "/Admin"
          }
        ],
        "id": "cd50ab90-d08f-481d-ba68-068467c4fb1f",
        "lastName": "Christian",
        "notBefore": 0,
        "requiredActions": [],
        "roles": [
          {
            "clientRole": false,
            "composite": true,
            "containerId": "Waangu-Marketplace",
            "description": "${role_default-roles}",
            "id": "a2dfd83a-4d95-4bb5-8cd7-066d4cb222ff",
            "name": "Commandes"
          },
          {
            "clientRole": false,
            "composite": false,
            "containerId": "Waangu-Marketplace",
            "description": "l'administrateur",
            "id": "535216b8-2870-44fb-8fbb-a498d585ba20",
            "name": "Administrateur"
          }
        ],
        "totp": false,
        "username": "katshchris2105"
      }
    ],
    "timestamp": "2025-04-30T05:50:07.522Z"
  }
}

GitHub Copilot: Here’s how to add filtering for your audit log by date (`YYYY-MM-DD`), actor, or action, and move the logic to a service:

---

#### 1. **Create a service for audit log filtering**

````typescript
import * as path from 'path';
import * as fs from 'fs';

export class AuditLogService {
  private logFilePath = path.join(__dirname, '..', '..', 'logs', 'audit.log');

  getAuditLogs(filters: { date?: string; actor?: string; action?: string }) {
    if (!fs.existsSync(this.logFilePath)) return null;
    const data = fs.readFileSync(this.logFilePath, 'utf-8');
    const logs = data
      .split('\n')
      .filter(line => line.trim() !== '')
      .map(line => {
        try {
          return JSON.parse(line);
        } catch {
          return { raw: line };
        }
      });

    // Filtering
    return logs.filter(entry => {
      if (!entry.message) return false;
      const { actor, action } = entry.message;
      const timestamp = entry.message.timestamp || entry.timestamp;
      let match = true;
      if (filters.actor) match = match && actor === filters.actor;
      if (filters.action) match = match && action === filters.action;
      if (filters.date && timestamp) {
        match = match && timestamp.startsWith(filters.date);
      }
      return match;
    });
  }
}
````

---

#### 2. **Register the service in your controller**

````typescript
import { AuditLogService } from './audit-log.service';
// ...existing code...

@Controller('users')
export class UsersController {
  private auditLogService = new AuditLogService();

  @Get('logs/audit')
  async getAuditLog(
    @Res() res: Response,
    @Query('date') date?: string,      // format: '2025-04-30'
    @Query('actor') actor?: string,
    @Query('action') action?: string,
  ) {
    const logs = this.auditLogService.getAuditLogs({ date, actor, action });
    if (logs === null) {
      res.status(404).send('Log file not found');
    } else {
      res.json(logs);
    }
  }

  // ...rest of your controller...
}
````

---

#### 3. **Usage examples**

- `/users/logs/audit?date=2025-04-30`
- `/users/logs/audit?actor=system`
- `/users/logs/audit?action=LIST_USERS`
- `/users/logs/audit?date=2025-04-30&actor=system&action=LIST_USERS`

---

**This will allow you to filter audit logs by date, actor, or action via query parameters.**

julesAsyst:  @Get('logs/audit')
  async getAuditLog(
    @Res() res: Response,
    @Query('date') date?: string,      // format: '2025-04-30'
    @Query('actor') actor?: string,
    @Query('action') action?: string,
  ) {
    const logs = await this.keycloakService.getAuditLogs({ date: date || null, actor: actor || null, action: action || null });
    if (logs === null) {
      res.status(404).send('Log file not found');
    } else {
      res.json(logs);
    }
  }

  the @query are required in swagger i want them optionnal

GitHub Copilot: To make the `@Query` parameters optional in Swagger UI, you should use the `@ApiQuery` decorator from `@nestjs/swagger` with `required: false`. Here’s how to do it:

````typescript
import { ApiQuery } from '@nestjs/swagger';
// ...existing code...

  @Get('logs/audit')
  @ApiOperation({ summary: 'Get audit logs with optional filters' })
  @ApiQuery({ name: 'date', required: false, description: "Format: 'YYYY-MM-DD'" })
  @ApiQuery({ name: 'actor', required: false })
  @ApiQuery({ name: 'action', required: false })
  async getAuditLog(
    @Res() res: Response,
    @Query('date') date?: string,      // format: '2025-04-30'
    @Query('actor') actor?: string,
    @Query('action') action?: string,
  ) {
    const logs = await this.keycloakService.getAuditLogs({ date: date || null, actor: actor || null, action: action || null });
    if (logs === null) {
      res.status(404).send('Log file not found');
    } else {
      res.json(logs);
    }
  }
````

This will make all three query parameters optional in Swagger UI.

julesAsyst: i want in the audit.log that the data comes into the order provided in logAction

GitHub Copilot: To ensure the fields in your `audit.log` appear in the exact order as in your `logEntry` object (`action`, `actor`, `timestamp`, `target`, `details`), you need to customize the Winston JSON formatter. By default, JSON.stringify preserves key order, but Winston may wrap your object or add metadata.

**Solution:**  
Use a custom formatter with Winston to stringify only your `logEntry` object.

Update your logger initialization as follows:

````typescript
import { Injectable, Scope, Inject } from '@nestjs/common';
import { REQUEST } from '@nestjs/core';
import * as winston from 'winston';

@Injectable({ scope: Scope.REQUEST })
export class LoggerService {
  private logger: winston.Logger;

  constructor(@Inject(REQUEST) private readonly request: any) {
    this.logger = winston.createLogger({
      level: 'info',
      format: winston.format.printf(({ message }) => {
        // message is the logEntry object
        return JSON.stringify(message);
      }),
      transports: [
        new winston.transports.File({ filename: 'logs/audit.log' }),
      ],
    });
  }

  logAction(action: string, target: any, details?: any) {
    const actor = this.request?.user?.username || 'system';
    const logEntry = {
      action,
      actor,
      timestamp: new Date().toISOString(),
      target,
      details,
    };
    this.logger.info(logEntry);
  }
}
````

**Now, each line in your audit log will have the fields in the order: `action`, `actor`, `timestamp`, `target`, `details`.**

julesAsyst: it worked now how can i return it
async getAuditLogs(filters: { date?: string; actor?: string; action?: string }) {
    const logFilePath = path.join(__dirname, '..','..', '..', 'logs', 'audit.log');
    if (!fs.existsSync(logFilePath)) return null;
    const data = fs.readFileSync(logFilePath, 'utf-8');
    const logs = data
      .split('\n')
      .filter(line => line.trim() !== '')
      .map(line => {
        try {
          return JSON.parse(line);
        } catch {
          return { raw: line };
        }
      });
    console.log(logs);
    // Filtering
    return logs.filter(entry => {
      if (!entry.message) return false;
      const { actor, action } = entry.message;
      const timestamp = entry.message.timestamp || entry.timestamp;
      let match = true;
      if (filters.actor) match = match && actor === filters.actor;
      if (filters.action) match = match && action === filters.action;
      if (filters.date && timestamp) {
        match = match && timestamp.startsWith(filters.date);
      }
      return match;
    });
  }

GitHub Copilot: You can return the filtered logs directly from your service as an array of objects. In your controller, just return the result (or use `res.json(logs)` if you use the Express response object).

**But:**  
Your current code expects each log entry to have a `message` property (i.e., `entry.message.actor`).  
However, your logger writes the log entry directly (not wrapped in a `message` property).  
So you should access `entry.actor`, `entry.action`, and `entry.timestamp` directly.

**Update your filter like this:**

````typescript
async getAuditLogs(filters: { date?: string; actor?: string; action?: string }) {
  const logFilePath = path.join(__dirname, '..','..', '..', 'logs', 'audit.log');
  if (!fs.existsSync(logFilePath)) return null;
  const data = fs.readFileSync(logFilePath, 'utf-8');
  const logs = data
    .split('\n')
    .filter(line => line.trim() !== '')
    .map(line => {
      try {
        return JSON.parse(line);
      } catch {
        return { raw: line };
      }
    });

  // Filtering
  return logs.filter(entry => {
    if (!entry.actor && !entry.action && !entry.timestamp) return false;
    let match = true;
    if (filters.actor) match = match && entry.actor === filters.actor;
    if (filters.action) match = match && entry.action === filters.action;
    if (filters.date && entry.timestamp) {
      match = match && entry.timestamp.startsWith(filters.date);
    }
    return match;
  });
}
````

**In your controller, just return the result:**

```typescript
@Get('logs/audit')
async getAuditLog(
  @Res() res: Response,
  @Query('date') date?: string,
  @Query('actor') actor?: string,
  @Query('action') action?: string,
) {
  const logs = await this.keycloakService.getAuditLogs({ date, actor, action });
  if (logs === null) {
    res.status(404).send('Log file not found');
  } else {
    res.json(logs);
  }
}
```

**Now you will get the filtered logs as JSON in the response.**

julesAsyst: add a filter by an interval of time start time hour and minute and end time hour and minute

GitHub Copilot: To add filtering by a time interval (start time and end time, including hour and minute) to your `getAuditLogs` method, you can accept two new parameters: `startTime` and `endTime` (format: `HH:mm`).  
You will then filter logs whose `timestamp` falls within the specified interval on the given date.

Here's how you can do it:

---

````typescript
async getAuditLogs(filters: { 
  date?: string; 
  actor?: string; 
  action?: string; 
  startTime?: string; // format: 'HH:mm'
  endTime?: string;   // format: 'HH:mm'
}) {
  const logFilePath = path.join(__dirname, '..','..', '..', 'logs', 'audit.log');
  if (!fs.existsSync(logFilePath)) return null;
  const data = fs.readFileSync(logFilePath, 'utf-8');
  const logs = data
    .split('\n')
    .filter(line => line.trim() !== '')
    .map(line => {
      try {
        return JSON.parse(line);
      } catch {
        return { raw: line };
      }
    });

  // Filtering
  return logs.filter(entry => {
    if (!entry.actor && !entry.action && !entry.timestamp) return false;
    let match = true;
    if (filters.actor) match = match && entry.actor === filters.actor;
    if (filters.action) match = match && entry.action === filters.action;
    if (filters.date && entry.timestamp) {
      match = match && entry.timestamp.startsWith(filters.date);
    }
    // Time interval filtering
    if (filters.startTime && filters.endTime && entry.timestamp) {
      // Extract time part from timestamp
      const time = entry.timestamp.substring(11, 16); // 'HH:mm'
      match = match && (time >= filters.startTime && time <= filters.endTime);
    }
    return match;
  });
}
````

---

**How to use:**  
- Add `startTime` and `endTime` as query params to your controller and Swagger decorators.
- Example:  
  `/users/logs/audit?date=2025-04-30&startTime=08:00&endTime=10:30`

---

**Controller Example:**

````typescript
// Add these decorators above your endpoint
@ApiQuery({ name: 'startTime', required: false, description: "Format: 'HH:mm'" })
@ApiQuery({ name: 'endTime', required: false, description: "Format: 'HH:mm'" })

// And in your method signature:
async getAuditLog(
  @Res() res: Response,
  @Query('date') date?: string,
  @Query('actor') actor?: string,
  @Query('action') action?: string,
  @Query('startTime') startTime?: string,
  @Query('endTime') endTime?: string,
) {
  const logs = await this.keycloakService.getAuditLogs({ date, actor, action, startTime, endTime });
  if (logs === null) {
    res.status(404).send('Log file not found');
  } else {
    res.json(logs);
  }
}
````

---

**This will allow you to filter logs by date, actor, action, and a time interval (hour and minute).**

julesAsyst: async findAllUsers(): Promise<UserRepresentation[]> {
    const url = `${process.env.KEYCLOAK_ADMIN_BASE_URL}/users`;
    const token = await this.getAdminToken();
    try {
      const response = await firstValueFrom(
        this.httpService.get(url, { headers: { Authorization: `Bearer ${token}` } }),
      );
      console.log('response', response);
      const users = response.data;
      const userRoles = await Promise.all(users.map(user => this.getUserRole(user.id, token)));
      const userGroups = await Promise.all(users.map(user => this.getUserGroups(user.id, token)));
      users.forEach((user, index) => {
        user.roles = userRoles[index];
        user.groups = userGroups[index];
      });
      this.loggerService.logAction('LIST_USERS', "Getting all Users", { returnedData: users });
      return users;
    } catch (error) {
      throw new HttpException(`Find all users failed: ${error.message}`, HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }
  seing this function how i integrated the logerService i would like you to all the functions in my TransactionService so that it tracks all that happen in the Transactions not just Keycloakservice only:

  //src/users/transactions/transactions.service.ts
  import { HttpException, HttpStatus, Injectable, NotFoundException } from '@nestjs/common';
  import { KeycloakService } from '../keycloak/keycloak.service';
  import { CreateUserDatabaseDto, CreateUserDto, UserRepresentation } from '../dto/create-user.dto';
  import { DatabaseService } from '../database/database.service';
  import { Connection } from 'mongoose';
  import { InjectConnection } from '@nestjs/mongoose';
  import { LoginDto } from 'src/users/dto/login.dto';
  import { LogoutDto } from 'src/users/dto/logout.dto';
  import { PageDto } from 'src/helpers/page-dto/page-dto';
  import { PageOptionsDto } from 'src/helpers/page-options-dto/page-options-dto';
  
  @Injectable()
  export class TransactionsService {
      constructor(
          private keycloakService: KeycloakService,
          private databaseService: DatabaseService,
          @InjectConnection() private readonly connection: Connection,
      ) { }
  
      async login(userDto: LoginDto): Promise<any> {
          try {
              const keycloakResponse = await this.keycloakService.login(userDto);
              if (!keycloakResponse || !keycloakResponse.access_token) {
                  throw new HttpException('Invalid credentials', HttpStatus.UNAUTHORIZED);
              }
  
              const dbUser = await this.databaseService.findUserByUsername(userDto.identifier) ||
                  await this.databaseService.findUserByEmail(userDto.identifier);
              if (!dbUser) {
                  // If the user doesn't exist in your DB, you might choose to create a new entry or throw an error.
                  throw new NotFoundException('User not found in database');
              }
  
              const mergedUser = {
                  ...dbUser,
                  // username: keycloakUser.username,
                  // email: keycloakUser.email,
                  // firstName: keycloakUser.firstName,
                  // lastName: keycloakUser.lastName,
                  // roles: keycloakUser.attributes?.role || [],
                  // add additional fields from dbUser as needed
              };
  
              // 4. Return a payload that includes the authentication tokens and merged user profile.
              return {
                  accessToken: keycloakResponse.access_token,
                  refreshToken: keycloakResponse.refresh_token,
                  // user: mergedUser,
              };
          } catch (error) {
              throw new HttpException(error.message || 'Login failed', HttpStatus.UNAUTHORIZED);
          }
      }
      
      async decodeToken(token: string): Promise<any> {
          try {
              const decodedData = await this.keycloakService.decodeJwt(token);
              return decodedData;
          } catch (error) {
              throw new HttpException(error.message || 'Failed to decode token', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async refreshAccessToken(token: string): Promise<any> {
          try {
              const refreshedToken = await this.keycloakService.refreshAccessToken(token);
              return refreshedToken;
          } catch (error) {
              throw new HttpException(error.message || 'Failed to refresh token', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async logout(token: string): Promise<any> {
          return this.keycloakService.logout(token);
      }
  
      async createUser(userDto: any): Promise<any> {
          let keycloakId;
          const session = await this.connection.startSession();
          session.startTransaction();
  
          try {
              const keycloakUserPayload = {
                  username: userDto.username,
                  email: userDto.email,
                  firstName: userDto.firstName,
                  lastName: userDto.lastName,
                  credentials: userDto.password ? [{ type: 'password', value: userDto.password, temporary: false }] : undefined,
                  enabled: true,
                  emailVerified: false,
                  attributes: {
                      phone: userDto.phone,
                      address: userDto.address,
                      cardNumber: userDto.cardNumber,
                      logo: userDto.logo,
                      status: userDto.status || 'pending',
                      group: userDto.group,
                  },
              };
  
              const createdKeycloakUser = await this.keycloakService.createUser(keycloakUserPayload);
              keycloakId = createdKeycloakUser.id;
  
              const userForDB = { ...userDto, keycloakId: createdKeycloakUser.id };
              const createdUser = await this.databaseService.createUser(userForDB, session);
  
              await session.commitTransaction();
              session.endSession();
  
              return {
                  message: 'User created successfully! Please check your email to verify your account.',
                  user: createdUser,
                  emailSent: createdKeycloakUser.emailVerified ? true : false, // Indicate email status
              };
          } catch (error) {
              await session.abortTransaction();
              session.endSession();
  
              if (keycloakId) {
                  try {
                      await this.keycloakService.deleteUser(keycloakId);
                  } catch (compensationError) {
                      console.error('Compensation error:', compensationError.message);
                  }
              }
  
              // Handle email-specific errors gracefully
              if (error.message.includes('Failed to send verification email')) {
                  console.warn('User created but email verification failed:', error.message);
                  return {
                      message: 'User created successfully, but failed to send verification email. Please verify manually.',
                      user: { username: userDto.username, email: userDto.email },
                      emailSent: false,
                  };
              }
  
              throw new HttpException(error.message || 'Failed to create user', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async createUserWithoutRoles(userDto: any): Promise<any> {
          let keycloakId;
          const session = await this.connection.startSession();
          session.startTransaction();
  
          try {
              const keycloakUserPayload = {
                  username: userDto.username,
                  email: userDto.email,
                  firstName: userDto.firstName,
                  lastName: userDto.lastName,
                  credentials: userDto.password ? [{ type: 'password', value: userDto.password, temporary: false }] : undefined,
                  enabled: true,
                  emailVerified: false,
                  attributes: {
                      phone: userDto.phone,
                      address: userDto.address,
                      cardNumber: userDto.cardNumber,
                      logo: userDto.logo,
                      status: userDto.status || 'pending',
                  },
              };
  
              const createdKeycloakUser = await this.keycloakService.createUserWithoutRoles(keycloakUserPayload);
              keycloakId = createdKeycloakUser.id;
  
              const userForDB = { ...userDto, keycloakId: createdKeycloakUser.id };
              const createdUser = await this.databaseService.createUser(userForDB, session);
  
              await session.commitTransaction();
              session.endSession();
  
              return {
                  message: 'User created successfully! Please check your email to verify your account.',
                  user: createdUser,
                  emailSent: createdKeycloakUser.emailVerified ? true : false, // Indicate email status
              };
          } catch (error) {
              await session.abortTransaction();
              session.endSession();
  
              if (keycloakId) {
                  try {
                      await this.keycloakService.deleteUser(keycloakId);
                  } catch (compensationError) {
                      console.error('Compensation error:', compensationError.message);
                  }
              }
  
              // Handle email-specific errors gracefully
              if (error.message.includes('Failed to send verification email')) {
                  console.warn('User created but email verification failed:', error.message);
                  return {
                      message: 'User created successfully, but failed to send verification email. Please verify manually.',
                      user: { username: userDto.username, email: userDto.email },
                      emailSent: false,
                  };
              }
  
              throw new HttpException(error.message || 'Failed to create user', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async updateUser(id: string, userDto: any): Promise<any> {
          // Fetch the user from the database to get the associated Keycloak ID
          const dbUser = await this.databaseService.findUserById(id);
          if (!dbUser || !dbUser.keycloakId) {
              throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
          }
  
          const keycloakId = dbUser.keycloakId;
          const keycloakOGUser = await this.keycloakService.findUserById(keycloakId);
  
          // Start a Mongoose session
          const session = await this.connection.startSession();
          session.startTransaction();
  
          try {
              // ---------------------- STEP 1: Keycloak Operation ----------------------
              // Build the payload for Keycloak. Adjust the payload as required by your Keycloak API.
              const keycloakUserPayload = Object.fromEntries(
                  Object.entries({
                      username: userDto.username,
                      email: userDto.email,
                      firstName: userDto.firstName,
                      lastName: userDto.lastName,
                      attributes: {
                          phone: userDto.phone,
                          address: userDto.address,
                          cardNumber: userDto.cardNumber,
                          logo: userDto.logo,
                          status: userDto.status || 'pending',
                          // role: userDto.role || keycloakOGUser.attributes.role,
                      },
                  }).filter(([_, value]) => value !== undefined && value !== null)
              );
  
              // Update the user in Keycloak.
              await this.keycloakService.updateUser(keycloakId, keycloakUserPayload);
  
              const userForDB = { ...userDto, keycloakId: keycloakId };
  
              // Pass the Mongoose session into the database service to ensure transactionality.
              const updatedUser = await this.databaseService.updateUser(id, userForDB, session);
  
              // Commit the transaction if both operations succeed.
              await session.commitTransaction();
              session.endSession();
              return updatedUser;
          } catch (error) {
              // Roll back the database changes
              await session.abortTransaction();
              session.endSession();
  
              // OPTIONAL: Compensate the Keycloak action by reverting the Keycloak user update if necessary.
              if (error && keycloakOGUser) {
                  try {
                      // Revert Keycloak changes if needed (implement revert logic in KeycloakService if applicable)
                      await this.keycloakService.updateUser(keycloakId, keycloakOGUser);
                      console.error('Error occurred, consider reverting Keycloak changes if necessary.');
                  } catch (compensationError) {
                      console.error('Compensation error:', compensationError.message);
                  }
              }
              throw new HttpException(error.message || 'Failed to update user transactionally', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async resetPassword(id: string, newPassword: string): Promise<any> {
          // Fetch the user from the database to get the associated Keycloak ID
          const dbUser = await this.databaseService.findUserById(id);
          if (!dbUser || !dbUser.keycloakId) {
              throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
          }
  
          const keycloakId = dbUser.keycloakId;
          return this.keycloakService.resetPassword(keycloakId, newPassword);
      }
  
      async findUserById(id: string): Promise<any> {
          let keycloakUser: any, dbUser: any;
  
          try {
              dbUser = await this.databaseService.findUserById(id);
          } catch (error) {
              console.error('Database fetch error:', error.message);
              throw new NotFoundException(`User with id ${id} not found in both systems.`);
          }
  
          try {
              keycloakUser = await this.keycloakService.findUserById(dbUser.keycloakId);
          } catch (error) {
              // Log error but allow fallback
              console.error('Keycloak fetch error:', error.message);
          }
  
  
          console.log('Database user:', dbUser);
          console.log('Keycloak user:', keycloakUser);
          // Prioritize Keycloak values if available and merge with database values
          const mergedUser: UserRepresentation = {
              ...dbUser,
              ...keycloakUser,
          };
  
          return mergedUser;
      }
  
  
      async findUserByUsername(username: string): Promise<any> {
          let keycloakUser: any, dbUser: any;
  
          try {
              dbUser = await this.databaseService.findUserByUsername(username);
          } catch (error) {
              console.error('Database fetch error:', error.message);
              throw new NotFoundException(`User with username ${username} not found in both systems.`);
          }
  
          try {
              keycloakUser = await this.keycloakService.findUserByUsername(username);
          } catch (error) {
              // Log error but allow fallback
              console.error('Keycloak fetch error:', error.message);
          }
  
          console.log('Database user:', dbUser);
          console.log('Keycloak user:', keycloakUser);
          // Prioritize Keycloak values if available and merge with database values
          const mergedUser: UserRepresentation = {
              ...dbUser,
              ...keycloakUser,
          };
  
          return mergedUser;
      }
  
      async getConnectedUsers(): Promise<any[]> {
          return this.keycloakService.getConnectedUsers();
      }
  
      async findAllUsersByRole(roleName: string): Promise<any[]> {
          let keycloakUsers: UserRepresentation[] = [];
  
          try {
              keycloakUsers = await this.keycloakService.findAllUsersByRole(roleName);
              console.log('Keycloak users:', keycloakUsers);
          } catch (error) {
              // Log error but allow fallback
              console.error('Keycloak fetch error:', error.message);
          }
  
          // let dbUsers: CreateUserDatabaseDto[] = [];
  
          // try {
          //     dbUsers = await this.databaseService.findAllUsersByRole(roleName);
          // } catch (error) {
          //     console.error('Database fetch error:', error.message);
          //     throw new NotFoundException(`Users with role ${roleName} not found in both systems.`);
          // }
  
          // console.log('Database users:', dbUsers);
  
          // Merge users from both sources, prioritizing Keycloak values if available
          // const mergedUsers: UserRepresentation[] = dbUsers.map(dbUser => {
          //     const keycloakUser = keycloakUsers.find(kcUser => kcUser.id === dbUser.keycloakId);
          //     return {
          //         ...dbUser,
          //         ...keycloakUser,
          //     };
          // });
  
          return keycloakUsers;
      }
  
      async findAllUsers(pageOptionsDto: PageOptionsDto): Promise<PageDto<CreateUserDatabaseDto>> {
          let keycloakUsers: any[] = [];
          let dbUsers;
  
          try {
              dbUsers = await this.databaseService.findAllUsers(pageOptionsDto);
          } catch (error) {
              console.error('Database fetch error:', error.message);
              throw new NotFoundException('Users not found in the database.');
          }
  
          try {
              keycloakUsers = await this.keycloakService.findAllUsers();
          } catch (error) {
              // Log error but allow fallback
              console.error('Keycloak fetch error:', error.message);
          }
  
          console.log('Database users:', dbUsers.data);
          console.log('Keycloak users:', keycloakUsers);
          // Merge users from both sources, prioritizing Keycloak values if available
          const mergedUsers: CreateUserDatabaseDto[] = dbUsers.data.map(dbUser => {
              const keycloakUser = keycloakUsers.find(kcUser => kcUser.id === dbUser.keycloakId);
              return {
                  ...dbUser,
                  ...keycloakUser,
              };
          });
          console.log('Merged users:', mergedUsers);
  
          return new PageDto(mergedUsers, dbUsers.meta);
      }
  
      async findUserByEmail(email: string): Promise<any> {
          let keycloakUser: any, dbUser: any;
  
          try {
              dbUser = await this.databaseService.findUserByEmail(email);
          } catch (error) {
              console.error('Database fetch error:', error.message);
              throw new NotFoundException(`User with email ${email} not found in both systems.`);
          }
  
          try {
              keycloakUser = await this.keycloakService.findUserByEmail(email);
          } catch (error) {
              // Log error but allow fallback
              console.error('Keycloak fetch error:', error.message);
          }
  
          console.log('Database user:', dbUser);
          console.log('Keycloak user:', keycloakUser);
          // Prioritize Keycloak values if available and merge with database values
          const mergedUser: UserRepresentation = {
              ...dbUser,
              ...keycloakUser,
          };
  
          return mergedUser;
      }
  
      async deleteUser(id: string): Promise<any> {
          // Start a Mongoose session
          const session = await this.connection.startSession();
          session.startTransaction();
  
          try {
              // Fetch the user from the database to get the associated Keycloak ID
              const dbUser = await this.databaseService.findUserById(id);
              if (!dbUser || !dbUser.keycloakId) {
                  throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
              }
  
              const keycloakId = dbUser.keycloakId;
  
               // Pass the Mongoose session into the database service to ensure transactionality
               const deletedUserDB = await this.databaseService.deleteUser(id, session);
               console.log('Database user deleted');
               
              // Delete the user in Keycloak
              await this.keycloakService.deleteUser(keycloakId);
              console.log('Keycloak user deleted');
  
             
  
              // Commit the transaction if both operations succeed
              await session.commitTransaction();
              session.endSession();
              return deletedUserDB;
          } catch (error) {
              // Roll back the database changes
              await session.abortTransaction();
              session.endSession();
  
              // OPTIONAL: Compensate the Keycloak action by recreating the Keycloak user if necessary
              console.error('Error occurred during user deletion:', error.message);
              throw new HttpException(error.message || 'Failed to delete user transactionally', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async createRole(roleName: string, description: string): Promise<any> {
          try {
              const createdRole = await this.keycloakService.createRole(roleName, description);
              return createdRole;
          } catch (error) {
              throw new HttpException(error.message || 'Failed to create role', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async deleteRole(roleName: string): Promise<any> {
          try {
              await this.keycloakService.deleteRole(roleName);
              return { message: `Role ${roleName} deleted successfully` };
          } catch (error) {
              throw new HttpException(error.message || 'Failed to delete role', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async updateRole(roleName: string, newName?: string, newDescription?: string): Promise<any> {
          try {
              const updatedRole = await this.keycloakService.updateRole(roleName, newName, newDescription);
              return updatedRole;
          } catch (error) {
              throw new HttpException(error.message || 'Failed to update role', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async assignRole(userId: string, roleName: string): Promise<void> {
          const dbUser = await this.databaseService.findUserById(userId);
          if (!dbUser || !dbUser.keycloakId) {
              throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
          }
          await this.keycloakService.assignRole(dbUser.keycloakId, roleName);
          // // Start a Mongoose session
          // const session = await this.connection.startSession();
          // session.startTransaction();
  
          // try {
          //     // Use the Keycloak ID to assign the role in Keycloak
          //     await this.keycloakService.assignRole(dbUser.keycloakId, roleName);
  
          //     // Update the role in the database within the transaction
          //     await this.databaseService.updateUserRole(userId, roleName, true, session);
  
          //     // Commit the transaction if both operations succeed
          //     await session.commitTransaction();
          //     session.endSession();
          // } catch (error) {
          //     // Roll back the database changes
          //     await session.abortTransaction();
          //     session.endSession();
  
          //     // Rollback: De-assign role in Keycloak if database update fails
          //     try {
          //         await this.keycloakService.deAssignRole(userId, roleName);
          //     } catch (compensationError) {
          //         console.error('Compensation error:', compensationError.message);
          //     }
  
          //     throw new HttpException(error.message || 'Failed to assign role transactionally', HttpStatus.INTERNAL_SERVER_ERROR);
          // }
      }
  
      async deAssignRole(userId: string, roleName: string): Promise<void> {
          const dbUser = await this.databaseService.findUserById(userId);
          if (!dbUser || !dbUser.keycloakId) {
              throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
          }
          await this.keycloakService.deAssignRole(dbUser.keycloakId, roleName);
          // // Start a Mongoose session
          // const session = await this.connection.startSession();
          // session.startTransaction();
  
          // try {
          //     // Use the Keycloak ID to de-assign the role in Keycloak
          //     await this.keycloakService.deAssignRole(dbUser.keycloakId, roleName);
  
          //     // Update the role in the database within the transaction
          //     await this.databaseService.updateUserRole(userId, roleName, false, session);
  
          //     // Commit the transaction if both operations succeed
          //     await session.commitTransaction();
          //     session.endSession();
          // } catch (error) {
          //     // Roll back the database changes
          //     await session.abortTransaction();
          //     session.endSession();
  
          //     // Rollback: Re-assign role in Keycloak if database update fails
          //     try {
          //         await this.keycloakService.assignRole(dbUser.keycloakId, roleName);
          //     } catch (compensationError) {
          //         console.error('Compensation error:', compensationError.message);
          //     }
  
          //     throw new HttpException(error.message || 'Failed to de-assign role transactionally', HttpStatus.INTERNAL_SERVER_ERROR);
          // }
      }
  
      async getAllRoles(): Promise<any[]> {
          try {
              return await this.keycloakService.getAllRoles();
          } catch (error) {
              throw new HttpException(error.message || 'Failed to fetch roles', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async getUserRoles(userId: string): Promise<any[]> {
          const dbUser = await this.databaseService.findUserById(userId);
          if (!dbUser || !dbUser.keycloakId) {
              throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
          }
          try {
              return await this.keycloakService.getUserRole(dbUser.keycloakId);
          } catch (error) {
              throw new HttpException(error.message || 'Failed to fetch user roles', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async createGroup(groupName: string, attributes?: Record<string, any>): Promise<any> {
          try {
              return await this.keycloakService.createGroup(groupName, attributes);
          } catch (error) {
              throw new HttpException(error.message || 'Failed to create group', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async updateGroup(groupId: string, groupName?: string, attributes?: Record<string, any>): Promise<any> {
          try {
              return await this.keycloakService.updateGroup(groupId, groupName, attributes);
          } catch (error) {
              throw new HttpException(error.message || 'Failed to update group', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async deleteGroup(groupId: string): Promise<any> {
          try {
              return await this.keycloakService.deleteGroup(groupId);
          } catch (error) {
              throw new HttpException(error.message || 'Failed to delete group', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async getAllGroups(): Promise<any[]> {
          try {
              return await this.keycloakService.getAllGroups();
          } catch (error) {
              throw new HttpException(error.message || 'Failed to fetch groups', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async addRoleToGroup(groupId: string, roleName: string): Promise<any> {
          try {
              return await this.keycloakService.addRoleToGroup(groupId, roleName);
          } catch (error) {
              throw new HttpException(error.message || 'Failed to add role to group', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async removeRoleFromGroup(groupId: string, roleName: string): Promise<any> {
          try {
              return await this.keycloakService.removeRoleFromGroup(groupId, roleName);
          } catch (error) {
              throw new HttpException(error.message || 'Failed to remove role from group', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async getGroupRoles(groupId: string): Promise<any> {
          try {
              return await this.keycloakService.getGroupRoles(groupId);
          } catch (error) {
              throw new HttpException(error.message || 'Failed to fetch group roles', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async addUserToGroup(userId: string, groupId: string): Promise<void> {
          const dbUser = await this.databaseService.findUserById(userId);
          console.log('User:', dbUser);
  
          if (!dbUser) {
              throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
          }
          try {
              await this.keycloakService.addUserToGroup(dbUser.keycloakId, groupId);
          } catch (error) {
              throw new HttpException(error.message || 'Failed to add user to group', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async removeUserFromGroup(userId: string, groupId: string): Promise<void> {
          const dbUser = await this.databaseService.findUserById(userId);
          if (!dbUser || !dbUser.keycloakId) {
              throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
          }
          try {
              await this.keycloakService.removeUserFromGroup(dbUser.keycloakId, groupId);
          } catch (error) {
              throw new HttpException(error.message || 'Failed to remove user from group', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async getAllUsersFromGroup(groupId: string): Promise<any[]> {
          try {
              return await this.keycloakService.getAllUsersFromGroup(groupId);
          } catch (error) {
              throw new HttpException(error.message || 'Failed to fetch users from group', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async getGroupById(groupId: string): Promise<any> {
          try {
              return await this.keycloakService.getGroupById(groupId);
          } catch (error) {
              throw new HttpException(error.message || 'Failed to fetch group by ID', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async getGroupByName(groupName: string): Promise<any> {
          try {
              return await this.keycloakService.getGroupByName(groupName);
          } catch (error) {
              throw new HttpException(error.message || 'Failed to fetch group by name', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  
      async getUserGroups(userId: string): Promise<any[]> {
          const dbUser = await this.databaseService.findUserById(userId);
          if (!dbUser || !dbUser.keycloakId) {
              throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
          }
          try {
              return await this.keycloakService.getUserGroups(dbUser.keycloakId);
          } catch (error) {
              throw new HttpException(error.message || 'Failed to fetch user groups', HttpStatus.INTERNAL_SERVER_ERROR);
          }
      }
  }

GitHub Copilot: To track all actions in your `TransactionsService` using your `LoggerService`, inject `LoggerService` and call `this.loggerService.logAction()` in each method, just like you do in your KeycloakService.

Below is a pattern you can follow.  
**Inject `LoggerService` in the constructor** and add logging to each method, for example:

````typescript
import { LoggerService } from '../keycloak/logger.service';
// ...existing imports...

@Injectable()
export class TransactionsService {
    constructor(
        private keycloakService: KeycloakService,
        private databaseService: DatabaseService,
        @InjectConnection() private readonly connection: Connection,
        private readonly loggerService: LoggerService, // <-- Inject LoggerService
    ) { }

    async login(userDto: LoginDto): Promise<any> {
        try {
            const keycloakResponse = await this.keycloakService.login(userDto);
            if (!keycloakResponse || !keycloakResponse.access_token) {
                throw new HttpException('Invalid credentials', HttpStatus.UNAUTHORIZED);
            }
            const dbUser = await this.databaseService.findUserByUsername(userDto.identifier) ||
                await this.databaseService.findUserByEmail(userDto.identifier);
            if (!dbUser) {
                throw new NotFoundException('User not found in database');
            }
            // Log the login action
            this.loggerService.logAction('LOGIN', userDto.identifier, { dbUser });

            return {
                accessToken: keycloakResponse.access_token,
                refreshToken: keycloakResponse.refresh_token,
            };
        } catch (error) {
            this.loggerService.logAction('LOGIN_FAILED', userDto.identifier, { error: error.message });
            throw new HttpException(error.message || 'Login failed', HttpStatus.UNAUTHORIZED);
        }
    }

    async decodeToken(token: string): Promise<any> {
        try {
            const decodedData = await this.keycloakService.decodeJwt(token);
            this.loggerService.logAction('DECODE_TOKEN', 'decodeToken', { token });
            return decodedData;
        } catch (error) {
            this.loggerService.logAction('DECODE_TOKEN_FAILED', 'decodeToken', { error: error.message });
            throw new HttpException(error.message || 'Failed to decode token', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async refreshAccessToken(token: string): Promise<any> {
        try {
            const refreshedToken = await this.keycloakService.refreshAccessToken(token);
            this.loggerService.logAction('REFRESH_TOKEN', 'refreshAccessToken', { token });
            return refreshedToken;
        } catch (error) {
            this.loggerService.logAction('REFRESH_TOKEN_FAILED', 'refreshAccessToken', { error: error.message });
            throw new HttpException(error.message || 'Failed to refresh token', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async logout(token: string): Promise<any> {
        try {
            const result = await this.keycloakService.logout(token);
            this.loggerService.logAction('LOGOUT', 'logout', { token });
            return result;
        } catch (error) {
            this.loggerService.logAction('LOGOUT_FAILED', 'logout', { error: error.message });
            throw error;
        }
    }

    async createUser(userDto: any): Promise<any> {
        // ...existing code...
        try {
            // ...existing code...
            this.loggerService.logAction('CREATE_USER', userDto.username, { userDto });
            return {
                message: 'User created successfully! Please check your email to verify your account.',
                user: createdUser,
                emailSent: createdKeycloakUser.emailVerified ? true : false,
            };
        } catch (error) {
            this.loggerService.logAction('CREATE_USER_FAILED', userDto.username, { error: error.message });
            // ...existing code...
            throw new HttpException(error.message || 'Failed to create user', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    // ...repeat for all other methods, e.g. createUserWithoutRoles, updateUser, resetPassword, etc...
}
````

**Summary:**  
- Inject `LoggerService` in your constructor.
- Call `this.loggerService.logAction('ACTION_NAME', target, details)` at the start or end of each method, and in catch blocks for failures.
- Use meaningful action names and targets for each operation.

This will ensure all important actions in your `TransactionsService` are tracked in your audit log.

julesAsyst: @workspace /explain Write an explanation for the active selection as paragraphs of text.

```typescript
async login(userDto: LoginDto): Promise<any> {
        try {
            const keycloakResponse = await this.keycloakService.login(userDto);
            if (!keycloakResponse || !keycloakResponse.access_token) {
                throw new HttpException('Invalid credentials', HttpStatus.UNAUTHORIZED);
            }
            // const dbUser = await this.databaseService.findUserByUsername(userDto.identifier) ||
            //     await this.databaseService.findUserByEmail(userDto.identifier);
            // if (!dbUser) {
            //     // If the user doesn't exist in your DB, you might choose to create a new entry or throw an error.
            //     throw new NotFoundException('User not found in database');
            // }
            
            return {
                accessToken: keycloakResponse.access_token,
                refreshToken: keycloakResponse.refresh_token,
            };
        } catch (error) {
            throw new HttpException(error.message || 'Login failed', HttpStatus.UNAUTHORIZED);
        }
    }
```



Workspace: This `login` method is an asynchronous function designed to authenticate a user using credentials provided in a `LoginDto` object. The function first attempts to log in the user by calling `this.keycloakService.login(userDto)`, which likely interacts with a Keycloak authentication server. If the response from Keycloak is missing or does not contain an `access_token`, the method throws an HTTP 401 Unauthorized exception, indicating invalid credentials.

There is a commented-out section that suggests an additional check against a local database to find the user by username or email. If the user is not found in the database, it would throw a `NotFoundException`. This logic is currently disabled, but it hints at a possible future enhancement where the application might synchronize or validate users against its own database in addition to Keycloak.

If authentication is successful, the method returns an object containing the `accessToken` and `refreshToken` received from Keycloak. These tokens are typically used for session management and to authorize subsequent requests. If any error occurs during the process, the method catches it and throws an HTTP 401 Unauthorized exception with an appropriate error message, ensuring that the client receives a clear indication of authentication failure.

julesAsyst: analyse this service and give me a list of the first parameter in the loggerService.logAction: the action
//src/users/transactions/transactions.service.ts
import { HttpException, HttpStatus, Injectable, NotFoundException } from '@nestjs/common';
import { KeycloakService } from '../keycloak/keycloak.service';
import { CreateUserDatabaseDto, CreateUserDto, UserRepresentation } from '../dto/create-user.dto';
import { DatabaseService } from '../database/database.service';
import { Connection } from 'mongoose';
import { InjectConnection } from '@nestjs/mongoose';
import { LoginDto } from 'src/users/dto/login.dto';
import { LogoutDto } from 'src/users/dto/logout.dto';
import { PageDto } from 'src/helpers/page-dto/page-dto';
import { PageOptionsDto } from 'src/helpers/page-options-dto/page-options-dto';
import { LoggerService } from '../keycloak/logger.service';

@Injectable()
export class TransactionsService {
    constructor(
        private keycloakService: KeycloakService,
        private databaseService: DatabaseService,
        @InjectConnection() private readonly connection: Connection,
        private readonly loggerService: LoggerService,
    ) { }

    async login(userDto: LoginDto): Promise<any> {
        try {
            const keycloakResponse = await this.keycloakService.login(userDto);
            if (!keycloakResponse || !keycloakResponse.access_token) {
                throw new HttpException('Invalid credentials', HttpStatus.UNAUTHORIZED);
            }

            const logData = {
                usernameOrEmail: userDto.identifier,
                accessToken: keycloakResponse.access_token ? 'Token generated' : 'No token',
            };
            this.loggerService.logAction('USER_LOGIN', 'User login attempt', logData);

            return {
                accessToken: keycloakResponse.access_token,
                refreshToken: keycloakResponse.refresh_token,
            };
        } catch (error) {
            throw new HttpException(error.message || 'Login failed', HttpStatus.UNAUTHORIZED);
        }
    }
    
    async decodeToken(token: string): Promise<any> {
        try {
            const decodedData = await this.keycloakService.decodeJwt(token);
            this.loggerService.logAction('DECODE_TOKEN', 'Decoding JWT token', { decodedData });
            return decodedData;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to decode token', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async refreshAccessToken(token: string): Promise<any> {
        try {
            const refreshedToken = await this.keycloakService.refreshAccessToken(token);
            this.loggerService.logAction('REFRESH_ACCESS_TOKEN', 'Refreshing access token', { tokenRefreshed: !!refreshedToken });
            return refreshedToken;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to refresh token', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async logout(token: string): Promise<any> {
        try {
            const logoutResponse = await this.keycloakService.logout(token);
            this.loggerService.logAction('USER_LOGOUT', 'User logout attempt', { tokenInvalidated: logoutResponse });
            return logoutResponse;
        } catch (error) {
            this.loggerService.logAction('USER_LOGOUT_FAILED', 'User logout failed', { error: error.message });
            throw new HttpException(error.message || 'Failed to logout', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async createUser(userDto: any): Promise<any> {
        let keycloakId;
        const session = await this.connection.startSession();
        session.startTransaction();

        try {
            const keycloakUserPayload = {
                username: userDto.username,
                email: userDto.email,
                firstName: userDto.firstName,
                lastName: userDto.lastName,
                credentials: userDto.password ? [{ type: 'password', value: userDto.password, temporary: false }] : undefined,
                enabled: true,
                emailVerified: false,
                attributes: {
                    phone: userDto.phone,
                    address: userDto.address,
                    cardNumber: userDto.cardNumber,
                    logo: userDto.logo,
                    status: userDto.status || 'pending',
                    group: userDto.group,
                },
            };

            const createdKeycloakUser = await this.keycloakService.createUser(keycloakUserPayload);
            keycloakId = createdKeycloakUser.id;

            const userForDB = { ...userDto, keycloakId: createdKeycloakUser.id };
            const createdUser = await this.databaseService.createUser(userForDB, session);

            await session.commitTransaction();
            session.endSession();

            const logData = {
                username: createdUser.username,
                email: createdUser.email,
                keycloakId: createdUser.keycloakId,
                status: createdUser.status,
            };
            this.loggerService.logAction('CREATE_USER', 'User created successfully', logData);

            return {
                message: 'User created successfully! Please check your email to verify your account.',
                user: createdUser,
                emailSent: createdKeycloakUser.emailVerified ? true : false, // Indicate email status
            };
        } catch (error) {
            await session.abortTransaction();
            session.endSession();

            if (keycloakId) {
                try {
                    await this.keycloakService.deleteUser(keycloakId);
                } catch (compensationError) {
                    console.error('Compensation error:', compensationError.message);
                }
            }

            // Handle email-specific errors gracefully
            if (error.message.includes('Failed to send verification email')) {
                console.warn('User created but email verification failed:', error.message);
                return {
                    message: 'User created successfully, but failed to send verification email. Please verify manually.',
                    user: { username: userDto.username, email: userDto.email },
                    emailSent: false,
                };
            }

            throw new HttpException(error.message || 'Failed to create user', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async createUserWithoutRoles(userDto: any): Promise<any> {
        let keycloakId;
        const session = await this.connection.startSession();
        session.startTransaction();

        try {
            const keycloakUserPayload = {
                username: userDto.username,
                email: userDto.email,
                firstName: userDto.firstName,
                lastName: userDto.lastName,
                credentials: userDto.password ? [{ type: 'password', value: userDto.password, temporary: false }] : undefined,
                enabled: true,
                emailVerified: false,
                attributes: {
                    phone: userDto.phone,
                    address: userDto.address,
                    cardNumber: userDto.cardNumber,
                    logo: userDto.logo,
                    status: userDto.status || 'pending',
                },
            };

            const createdKeycloakUser = await this.keycloakService.createUserWithoutRoles(keycloakUserPayload);
            keycloakId = createdKeycloakUser.id;

            const userForDB = { ...userDto, keycloakId: createdKeycloakUser.id };
            const createdUser = await this.databaseService.createUser(userForDB, session);

            await session.commitTransaction();
            session.endSession();

            const logData = {
                username: createdUser.username,
                email: createdUser.email,
                keycloakId: createdUser.keycloakId,
                status: createdUser.status,
            };
            this.loggerService.logAction('CREATE_USER_WITHOUT_ROLES', 'User created successfully without roles', logData);

            return {
                message: 'User created successfully! Please check your email to verify your account.',
                user: createdUser,
                emailSent: createdKeycloakUser.emailVerified ? true : false, // Indicate email status
            };
        } catch (error) {
            await session.abortTransaction();
            session.endSession();

            if (keycloakId) {
                try {
                    await this.keycloakService.deleteUser(keycloakId);
                } catch (compensationError) {
                    console.error('Compensation error:', compensationError.message);
                }
            }

            // Handle email-specific errors gracefully
            if (error.message.includes('Failed to send verification email')) {
                console.warn('User created but email verification failed:', error.message);
                return {
                    message: 'User created successfully, but failed to send verification email. Please verify manually.',
                    user: { username: userDto.username, email: userDto.email },
                    emailSent: false,
                };
            }

            throw new HttpException(error.message || 'Failed to create user', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async updateUser(id: string, userDto: any): Promise<any> {
        // Fetch the user from the database to get the associated Keycloak ID
        const dbUser = await this.databaseService.findUserById(id);
        if (!dbUser || !dbUser.keycloakId) {
            throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
        }

        const keycloakId = dbUser.keycloakId;
        const keycloakOGUser = await this.keycloakService.findUserById(keycloakId);

        // Start a Mongoose session
        const session = await this.connection.startSession();
        session.startTransaction();

        try {
            // ---------------------- STEP 1: Keycloak Operation ----------------------
            // Build the payload for Keycloak. Adjust the payload as required by your Keycloak API.
            const keycloakUserPayload = Object.fromEntries(
                Object.entries({
                    username: userDto.username,
                    email: userDto.email,
                    firstName: userDto.firstName,
                    lastName: userDto.lastName,
                    attributes: {
                        phone: userDto.phone,
                        address: userDto.address,
                        cardNumber: userDto.cardNumber,
                        logo: userDto.logo,
                        status: userDto.status || 'pending',
                    },
                }).filter(([_, value]) => value !== undefined && value !== null)
            );

            // Update the user in Keycloak.
            await this.keycloakService.updateUser(keycloakId, keycloakUserPayload);

            const userForDB = { ...userDto, keycloakId: keycloakId };

            // Pass the Mongoose session into the database service to ensure transactionality.
            const updatedUser = await this.databaseService.updateUser(id, userForDB, session);

            // Commit the transaction if both operations succeed.
            await session.commitTransaction();
            session.endSession();

            // Log the action with updated user data
            const mergedUser: UserRepresentation = {
                ...dbUser,
                ...keycloakUserPayload,
            };
            this.loggerService.logAction('UPDATE_USER', 'User updated successfully', { updatedData: mergedUser });

            return updatedUser;
        } catch (error) {
            // Roll back the database changes
            await session.abortTransaction();
            session.endSession();

            // OPTIONAL: Compensate the Keycloak action by reverting the Keycloak user update if necessary.
            if (error && keycloakOGUser) {
                try {
                    // Revert Keycloak changes if needed (implement revert logic in KeycloakService if applicable)
                    await this.keycloakService.updateUser(keycloakId, keycloakOGUser);
                    console.error('Error occurred, consider reverting Keycloak changes if necessary.');
                } catch (compensationError) {
                    console.error('Compensation error:', compensationError.message);
                }
            }
            throw new HttpException(error.message || 'Failed to update user transactionally', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async resetPassword(id: string, newPassword: string): Promise<any> {
        // Fetch the user from the database to get the associated Keycloak ID
        const dbUser = await this.databaseService.findUserById(id);
        if (!dbUser || !dbUser.keycloakId) {
            throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
        }

        const keycloakId = dbUser.keycloakId;
        const resetResponse = await this.keycloakService.resetPassword(keycloakId, newPassword);

        // Log the action with relevant data
        this.loggerService.logAction('RESET_PASSWORD', 'Password reset successfully', {
            userId: id,
            keycloakId: keycloakId,
            resetStatus: resetResponse ? 'Success' : 'Failed',
        });

        return resetResponse;
    }

    async findUserById(id: string): Promise<any> {
        let keycloakUser: any, dbUser: any;

        try {
            dbUser = await this.databaseService.findUserById(id);
        } catch (error) {
            console.error('Database fetch error:', error.message);
            throw new NotFoundException(`User with id ${id} not found in both systems.`);
        }

        try {
            keycloakUser = await this.keycloakService.findUserById(dbUser.keycloakId);
        } catch (error) {
            // Log error but allow fallback
            console.error('Keycloak fetch error:', error.message);
        }

        console.log('Database user:', dbUser);
        console.log('Keycloak user:', keycloakUser);
        // Prioritize Keycloak values if available and merge with database values
        const mergedUser: UserRepresentation = {
            ...dbUser,
            ...keycloakUser,
        };

        this.loggerService.logAction('FIND_USER_BY_ID', "Fetching user by ID", { returnedData: mergedUser });

        return mergedUser;
    }

    async findUserByUsername(username: string): Promise<any> {
        let keycloakUser: any, dbUser: any;

        try {
            dbUser = await this.databaseService.findUserByUsername(username);
        } catch (error) {
            console.error('Database fetch error:', error.message);
            throw new NotFoundException(`User with username ${username} not found in both systems.`);
        }

        try {
            keycloakUser = await this.keycloakService.findUserByUsername(username);
        } catch (error) {
            // Log error but allow fallback
            console.error('Keycloak fetch error:', error.message);
        }

        console.log('Database user:', dbUser);
        console.log('Keycloak user:', keycloakUser);
        // Prioritize Keycloak values if available and merge with database values
        const mergedUser: UserRepresentation = {
            ...dbUser,
            ...keycloakUser,
        };

        this.loggerService.logAction('FIND_USER_BY_USERNAME', "Fetching user by username", { returnedData: mergedUser });

        return mergedUser;
    }

    async getConnectedUsers(): Promise<any[]> {
        const connectedUsers = await this.keycloakService.getConnectedUsers();
        this.loggerService.logAction('GET_CONNECTED_USERS', "Fetching connected users", { returnedData: connectedUsers });
        return connectedUsers;
    }

    async findAllUsersByRole(roleName: string): Promise<any[]> {
        let keycloakUsers: UserRepresentation[] = [];

        try {
            keycloakUsers = await this.keycloakService.findAllUsersByRole(roleName);
            console.log('Keycloak users:', keycloakUsers);
        } catch (error) {
            console.error('Keycloak fetch error:', error.message);
        }
        this.loggerService.logAction('LIST_USERS_BY_ROLE', `Getting all Users by Role: {roleName}`, { roleName, returnedData: keycloakUsers });
        return keycloakUsers;
    }

    async findAllUsers(pageOptionsDto: PageOptionsDto): Promise<PageDto<CreateUserDatabaseDto>> {
        let keycloakUsers: any[] = [];
        let dbUsers;

        try {
            dbUsers = await this.databaseService.findAllUsers(pageOptionsDto);
        } catch (error) {
            console.error('Database fetch error:', error.message);
            throw new NotFoundException('Users not found in the database.');
        }

        try {
            keycloakUsers = await this.keycloakService.findAllUsers();
        } catch (error) {
            // Log error but allow fallback
            console.error('Keycloak fetch error:', error.message);
        }

        console.log('Database users:', dbUsers.data);
        console.log('Keycloak users:', keycloakUsers);
        // Merge users from both sources, prioritizing Keycloak values if available
        const mergedUsers: CreateUserDatabaseDto[] = dbUsers.data.map(dbUser => {
            const keycloakUser = keycloakUsers.find(kcUser => kcUser.id === dbUser.keycloakId);
            return {
                ...dbUser,
                ...keycloakUser,
            };
        });
        console.log('Merged users:', mergedUsers);
        this.loggerService.logAction('LIST_USERS', "Getting all Users", { returnedData: mergedUsers });
        return new PageDto(mergedUsers, dbUsers.meta);
    }

    async findUserByEmail(email: string): Promise<any> {
        let keycloakUser: any, dbUser: any;

        try {
            dbUser = await this.databaseService.findUserByEmail(email);
        } catch (error) {
            console.error('Database fetch error:', error.message);
            throw new NotFoundException(`User with email ${email} not found in both systems.`);
        }

        try {
            keycloakUser = await this.keycloakService.findUserByEmail(email);
        } catch (error) {
            // Log error but allow fallback
            console.error('Keycloak fetch error:', error.message);
        }

        console.log('Database user:', dbUser);
        console.log('Keycloak user:', keycloakUser);
        // Prioritize Keycloak values if available and merge with database values
        const mergedUser: UserRepresentation = {
            ...dbUser,
            ...keycloakUser,
        };

        this.loggerService.logAction('FIND_USER_BY_EMAIL', "Fetching user by email", { returnedData: mergedUser });

        return mergedUser;
    }

    async deleteUser(id: string): Promise<any> {
        // Start a Mongoose session
        const session = await this.connection.startSession();
        session.startTransaction();

        try {
            // Fetch the user from the database to get the associated Keycloak ID
            const dbUser = await this.databaseService.findUserById(id);
            if (!dbUser || !dbUser.keycloakId) {
                throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
            }

            const keycloakId = dbUser.keycloakId;

            // Pass the Mongoose session into the database service to ensure transactionality
            const deletedUserDB = await this.databaseService.deleteUser(id, session);
            console.log('Database user deleted');
            
            // Delete the user in Keycloak
            await this.keycloakService.deleteUser(keycloakId);
            console.log('Keycloak user deleted');

            // Commit the transaction if both operations succeed
            await session.commitTransaction();
            session.endSession();

            this.loggerService.logAction('DELETE_USER', "User deleted successfully", { userId: id, keycloakId });

            return deletedUserDB;
        } catch (error) {
            // Roll back the database changes
            await session.abortTransaction();
            session.endSession();

            // OPTIONAL: Compensate the Keycloak action by recreating the Keycloak user if necessary
            console.error('Error occurred during user deletion:', error.message);

            throw new HttpException(error.message || 'Failed to delete user transactionally', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async createRole(roleName: string, description: string): Promise<any> {
        try {
            const createdRole = await this.keycloakService.createRole(roleName, description);
            this.loggerService.logAction('CREATE_ROLE', 'Role created successfully', { roleName, description });
            return createdRole;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to create role', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async deleteRole(roleName: string): Promise<any> {
        try {
            await this.keycloakService.deleteRole(roleName);
            this.loggerService.logAction('DELETE_ROLE', 'Role deleted successfully', { roleName });
            return { message: `Role ${roleName} deleted successfully` };
        } catch (error) {
            throw new HttpException(error.message || 'Failed to delete role', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async updateRole(roleName: string, newName?: string, newDescription?: string): Promise<any> {
        try {
            const updatedRole = await this.keycloakService.updateRole(roleName, newName, newDescription);
            this.loggerService.logAction('UPDATE_ROLE', 'Role updated successfully', { roleName, newName, newDescription });
            return updatedRole;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to update role', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async assignRole(userId: string, roleName: string): Promise<void> {
        const dbUser = await this.databaseService.findUserById(userId);
        if (!dbUser || !dbUser.keycloakId) {
            throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
        }
        await this.keycloakService.assignRole(dbUser.keycloakId, roleName);
        this.loggerService.logAction('ASSIGN_ROLE', 'Role assigned to user', { userId, roleName });
    }

    async deAssignRole(userId: string, roleName: string): Promise<void> {
        const dbUser = await this.databaseService.findUserById(userId);
        if (!dbUser || !dbUser.keycloakId) {
            throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
        }
        await this.keycloakService.deAssignRole(dbUser.keycloakId, roleName);
        this.loggerService.logAction('DE_ASSIGN_ROLE', 'Role de-assigned from user', { userId, roleName });
    }

    async getAllRoles(): Promise<any[]> {
        try {
            const roles = await this.keycloakService.getAllRoles();
            this.loggerService.logAction('GET_ALL_ROLES', 'Fetched all roles', { returnedData: roles });
            return roles;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to fetch roles', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async getUserRoles(userId: string): Promise<any[]> {
        const dbUser = await this.databaseService.findUserById(userId);
        if (!dbUser || !dbUser.keycloakId) {
            throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
        }
        try {
            const roles = await this.keycloakService.getUserRole(dbUser.keycloakId);
            this.loggerService.logAction('GET_USER_ROLES', 'Fetched user roles', { userId, returnedData: roles });
            return roles;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to fetch user roles', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async createGroup(groupName: string, attributes?: Record<string, any>): Promise<any> {
        try {
            const createdGroup = await this.keycloakService.createGroup(groupName, attributes);
            this.loggerService.logAction('CREATE_GROUP', 'Group created successfully', { groupName, attributes });
            return createdGroup;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to create group', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async updateGroup(groupId: string, groupName?: string, attributes?: Record<string, any>): Promise<any> {
        try {
            const updatedGroup = await this.keycloakService.updateGroup(groupId, groupName, attributes);
            this.loggerService.logAction('UPDATE_GROUP', 'Group updated successfully', { groupId, groupName, attributes });
            return updatedGroup;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to update group', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async deleteGroup(groupId: string): Promise<any> {
        try {
            const deletedGroup = await this.keycloakService.deleteGroup(groupId);
            this.loggerService.logAction('DELETE_GROUP', 'Group deleted successfully', { groupId });
            return deletedGroup;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to delete group', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async getAllGroups(): Promise<any[]> {
        try {
            const groups = await this.keycloakService.getAllGroups();
            this.loggerService.logAction('GET_ALL_GROUPS', 'Fetched all groups', { returnedData: groups });
            return groups;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to fetch groups', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async addRoleToGroup(groupId: string, roleName: string): Promise<any> {
        try {
            const result = await this.keycloakService.addRoleToGroup(groupId, roleName);
            this.loggerService.logAction('ADD_ROLE_TO_GROUP', 'Role added to group', { groupId, roleName });
            return result;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to add role to group', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async removeRoleFromGroup(groupId: string, roleName: string): Promise<any> {
        try {
            const result = await this.keycloakService.removeRoleFromGroup(groupId, roleName);
            this.loggerService.logAction('REMOVE_ROLE_FROM_GROUP', 'Role removed from group', { groupId, roleName });
            return result;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to remove role from group', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async getGroupRoles(groupId: string): Promise<any> {
        try {
            const roles = await this.keycloakService.getGroupRoles(groupId);
            this.loggerService.logAction('GET_GROUP_ROLES', 'Fetched group roles', { groupId, returnedData: roles });
            return roles;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to fetch group roles', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async addUserToGroup(userId: string, groupId: string): Promise<void> {
        const dbUser = await this.databaseService.findUserById(userId);
        console.log('User:', dbUser);

        if (!dbUser) {
            throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
        }
        try {
            await this.keycloakService.addUserToGroup(dbUser.keycloakId, groupId);
            this.loggerService.logAction('ADD_USER_TO_GROUP', 'User added to group', { userId, groupId });
        } catch (error) {
            throw new HttpException(error.message || 'Failed to add user to group', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async removeUserFromGroup(userId: string, groupId: string): Promise<void> {
        const dbUser = await this.databaseService.findUserById(userId);
        if (!dbUser || !dbUser.keycloakId) {
            throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
        }
        try {
            await this.keycloakService.removeUserFromGroup(dbUser.keycloakId, groupId);
            this.loggerService.logAction('REMOVE_USER_FROM_GROUP', 'User removed from group', { userId, groupId });
        } catch (error) {
            throw new HttpException(error.message || 'Failed to remove user from group', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async getAllUsersFromGroup(groupId: string): Promise<any[]> {
        try {
            const users = await this.keycloakService.getAllUsersFromGroup(groupId);
            this.loggerService.logAction('GET_ALL_USERS_FROM_GROUP', 'Fetched all users from group', { groupId, returnedData: users });
            return users;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to fetch users from group', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async getGroupById(groupId: string): Promise<any> {
        try {
            const group = await this.keycloakService.getGroupById(groupId);
            this.loggerService.logAction('GET_GROUP_BY_ID', 'Fetched group by ID', { groupId, returnedData: group });
            return group;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to fetch group by ID', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async getGroupByName(groupName: string): Promise<any> {
        try {
            const group = await this.keycloakService.getGroupByName(groupName);
            this.loggerService.logAction('GET_GROUP_BY_NAME', 'Fetched group by name', { groupName, returnedData: group });
            return group;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to fetch group by name', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    async getUserGroups(userId: string): Promise<any[]> {
        const dbUser = await this.databaseService.findUserById(userId);
        if (!dbUser || !dbUser.keycloakId) {
            throw new HttpException('User not found or Keycloak ID missing', HttpStatus.NOT_FOUND);
        }
        try {
            const groups = await this.keycloakService.getUserGroups(dbUser.keycloakId);
            this.loggerService.logAction('GET_USER_GROUPS', 'Fetched user groups', { userId, returnedData: groups });
            return groups;
        } catch (error) {
            throw new HttpException(error.message || 'Failed to fetch user groups', HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
}

